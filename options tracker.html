<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Options Analysis</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* Critical full-width overrides */
    html, body {
        width: 100% !important;
        max-width: 100% !important;
        overflow-x: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    /* Override any Bootstrap constraints */
    .container-fluid {
        width: 100% !important;
        max-width: 100% !important;
        padding-left: 15px !important;
        padding-right: 15px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Force any parent containers to full width */
    .content-outer, .content-fauxcolumn-outer, .region-inner,
    .main-inner, .columns-inner, .content, .post-body {
        width: 100% !important;
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
    }

    /* Force table to use full width */
    .table-responsive {
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    /* Hide all index columns from tables */
    table.table tr td:first-child:empty,
    table.dataTable tr td:first-child.dataTables_empty,
    table.table tr th.index,
    table.table tr td.index,
    table tr td:first-child:has(.row-number),
    table tr th:first-child:has(.row-number),
    table.dataTable tbody td.dt-body-center:first-child,
    .row-index,
    .row-number,
    .index-column {
        display: none !important;
    }

    /* Hide row numbers/indices that might be added by browsers or libraries */
    .table > tbody > tr > td.index,
    .table > tbody > tr > th.index {
        display: none !important;
    }

    /* If DataTables is used, hide row numbers */
    table.dataTable tbody td:first-child,
    table.dataTable tbody th:first-child {
        display: table-cell !important;
    }

    /* Hide index-related rows */
    tr.index-row,
    tr[data-index="true"],
    tr.hide-index {
        display: none !important;
    }

    /* Original styles */
    .profit {
        color: green;
        font-weight: bold;
    }
    .loss {
        color: red;
        font-weight: bold;
    }
    .filter-btn.active {
        background-color: #0d6efd;
        color: white;
    }

    .positive-change {
        background-color: rgba(75, 192, 192, 0.2);
    }
    .negative-change {
        background-color: rgba(255, 99, 132, 0.2);
    }
    .sortable {
        cursor: pointer;
        position: relative;
    }
    .sortable:hover {
        background-color: #f0f0f0;
    }
    .sortable::after {
        content: '⇵';
        margin-left: 5px;
        opacity: 0.3;
    }
    .sortable.asc::after {
        content: '↑';
        opacity: 1;
    }
    .sortable.desc::after {
        content: '↓';
        opacity: 1;
    }
    .status-open {
        color: blue;
        font-weight: bold;
    }
    .status-done {
        color: purple;
        font-weight: bold;
    }

    /* Tab styles */
    .data-view-tabs {
        margin-bottom: 15px;
    }

    .data-view-tabs .nav-link {
        padding: 8px 15px;
        border-radius: 4px 4px 0 0;
        color: #495057;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-bottom: none;
        margin-right: 5px;
    }

    .data-view-tabs .nav-link.active {
        color: #0d6efd;
        background-color: #fff;
        border-bottom: 1px solid #fff;
        font-weight: 500;
    }

    .data-view-tabs .nav-link:hover:not(.active) {
        background-color: #e9ecef;
    }

    /* Price range section styles */
    .price-range-section {
        margin-top: 30px;
        margin-bottom: 30px;
    }

    .price-range-table .table th,
    .price-range-table .table td {
        padding: 6px 8px;
        font-size: 0.9rem;
    }

    .price-range-table h4 {
        padding: 10px;
        margin: 0;
        color: white;
    }

    .medium-high-header {
        background-color: #17a2b8;
    }

    .high-header {
        background-color: #28a745;
    }

    /* New style for high quantity alerts */
    .high-quantity {
        background-color: #ffeeba;
        color: #856404;
        font-weight: bold;
    }

    /* Live bid/ask styles */
    .live-data {
        background-color: rgba(0, 123, 255, 0.1);
    }

    /* Custom highlighting for options */
    .highlight-red {
        background-color: rgba(255, 99, 132, 0.3) !important;
    }
    .highlight-green {
        background-color: rgba(75, 192, 192, 0.3) !important;
    }
    .highlight-blue {
        background-color: rgba(54, 162, 235, 0.3) !important;
    }
    .highlight-yellow {
        background-color: rgba(255, 206, 86, 0.3) !important;
    }
    .highlight-purple {
        background-color: rgba(153, 102, 255, 0.3) !important;
    }

    /* Context menu styling */
    .context-menu {
        display: none;
        position: absolute;
        z-index: 1000;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.3);
        padding: 5px 0;
    }

    .context-menu-item {
        padding: 8px 15px;
        cursor: pointer;
    }

    .context-menu-item:hover {
        background-color: #f0f0f0;
    }

    .color-option {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin-right: 10px;
        border-radius: 3px;
        vertical-align: middle;
    }

    /* Add this to your existing styles */
.color-badge {
display: inline-block;
width: 16px;
height: 16px;
border-radius: 3px;
margin-right: 5px;
vertical-align: middle;
border: 1px solid rgba(0,0,0,0.1);
}

    /* Milestone badge styles */
.milestone-badge {
padding: 4px 8px;
border-radius: 4px;
font-weight: bold;
display: inline-block;
}
.milestone-25 {
background-color: rgba(255, 193, 7, 0.2);
color: #856404;
}
.milestone-50 {
background-color: rgba(255, 165, 0, 0.3);
color: #804000;
}
.milestone-75 {
background-color: rgba(220, 53, 69, 0.2);
color: #721c24;
}
.milestone-new {
background-color: rgba(108, 117, 125, 0.2);
color: #495057;
}

    /* Add blinking animation for high quantities */
@keyframes blink-high-qty {
    0% { background-color: #ffeeba; }
    50% { background-color: #fff3cd; }
    100% { background-color: #ffeeba; }
}

.high-qty-blink {
    animation: blink-high-qty 1.5s infinite;
}

    /* Style for rows with high quantities */
.high-qty-row {
    background-color: #ff0033 !important; /* Light red with transparency */
}

  </style>
</head>
<body>
<div class="container-fluid">
  <h1 class="text-center mb-3">Options Orders Analysis</h1>

  <div class="row mb-3">
    <div class="col-md-6">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <button id="refreshBtn" class="btn btn-primary me-2">Refresh Data</button>
          <span class="text-muted">Last updated: <span id="lastUpdated">Never</span></span>
        </div>
        <div>
          <div class="btn-group" role="group">
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="all">All</button>
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="profit">Profit</button>
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="loss">Loss</button>
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="buyer">Buyer</button>
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="seller">Seller</button>
            <button type="button" class="btn btn-outline-primary filter-btn active" data-filter="open">Open</button>
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="done">Done</button>
            <button type="button" class="btn btn-outline-primary filter-btn" data-filter="new">New Only</button>
            <button type="button" class="btn btn-outline-secondary" id="clearFiltersBtn">Clear Filters</button>
          </div>
          <!-- Date range filter buttons -->
          <div class="btn-group mt-2" role="group">
            <span class="me-2 align-self-center"><strong>Date:</strong></span>
            <button type="button" class="btn btn-outline-info date-filter-btn" data-days="1">1 Day</button>
            <button type="button" class="btn btn-outline-info date-filter-btn" data-days="2">2 Days</button>
            <button type="button" class="btn btn-outline-info date-filter-btn" data-days="3">3 Days</button>
            <button type="button" class="btn btn-outline-info date-filter-btn" data-days="7">1 Week</button>
            <button type="button" class="btn btn-outline-info date-filter-btn" data-days="0" data-default="true">All Time</button>
            <button type="button" class="btn btn-outline-secondary" id="customDateRangeBtn" data-bs-toggle="modal" data-bs-target="#customDateRangeModal">Custom Range</button>
          </div>
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <div class="card">
        <div class="card-body">
          <div class="row">
            <div class="col-md-3 text-center">
              <h5>Total</h5>
              <h3 id="totalOptions">0</h3>
            </div>
            <div class="col-md-3 text-center">
              <h5>Profitable</h5>
              <h3 id="profitableOptions" class="profit">0</h3>
            </div>
            <div class="col-md-3 text-center">
              <h5>Losing</h5>
              <h3 id="losingOptions" class="loss">0</h3>
            </div>
            <div class="col-md-3 text-center">
              <h5>B:S / O:D</h5>
              <h3 id="buyerSellerRatio">0:0 / 0:0</h3>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Price Range Analysis Section (4 tables) -->
  <div class="row price-range-section mb-3">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header bg-primary text-white">
          <h4>Price Range Analysis</h4>
        </div>
        <div class="card-body">
          <div class="row">
            <!-- +10% to +25% Table -->
            <div class="col-md-6 price-range-table">
              <div class="card mb-3">
                <div class="card-header bg-info text-white">
                  <h4>+10% to +25% Price Change</h4>
                </div>
                <div class="card-body">
                  <div class="table-responsive">
                    <table class="table table-striped table-hover">
                      <thead>
                      <tr>
                        <th>Symbol</th>
                        <th>Strike</th>
                        <th>Type</th>
                        <th>Role</th>
                        <th>PCR</th>
                        <th>Original LTP</th>
                        <th>Current LTP</th>
                        <th>Change %</th>
                        <th>Milestone</th>
                        <th>Lot Size</th>
                        <th>Live Bid</th>
                        <th>Live Ask</th>
                        <th>Status</th>
                      </tr>
                      </thead>
                      <tbody id="lowMediumTableBody">
                      <!-- Low-medium range table rows will be added here -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>

            <!-- +25% to +50% Table -->
            <div class="col-md-6 price-range-table">
              <div class="card">
                <div class="card-header medium-high-header text-white">
                  <h4>+25% to +50% Price Change</h4>
                </div>
                <div class="card-body">
                  <div class="table-responsive">
                    <table class="table table-striped table-hover">
                      <thead>
                      <tr>
                        <th>Symbol</th>
                        <th>Strike</th>
                        <th>Type</th>
                        <th>Role</th>
                        <th>PCR</th>
                        <th>Original LTP</th>
                        <th>Current LTP</th>
                        <th>Change %</th>
                        <th>Milestone</th>
                        <th>Lot Size</th>
                        <th>Live Bid</th>
                        <th>Live Ask</th>
                        <th>Status</th>
                      </tr>
                      </thead>
                      <tbody id="mediumHighTableBody">
                      <!-- Medium-high range table rows will be added here -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="row mt-3">
            <!-- +50% to +75% Table -->
            <div class="col-md-6 price-range-table">
              <div class="card">
                <div class="card-header high-header text-white">
                  <h4>+50% to +75% Price Change</h4>
                </div>
                <div class="card-body">
                  <div class="table-responsive">
                    <table class="table table-striped table-hover">
                      <thead>
                      <tr>
                        <th>Symbol</th>
                        <th>Strike</th>
                        <th>Type</th>
                        <th>Role</th>
                        <th>PCR</th>
                        <th>Original LTP</th>
                        <th>Current LTP</th>
                        <th>Change %</th>
                        <th>Milestone</th>
                        <th>Lot Size</th>
                        <th>Live Bid</th>
                        <th>Live Ask</th>
                        <th>Status</th>
                      </tr>
                      </thead>
                      <tbody id="highTableBody">
                      <!-- High range table rows will be added here -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>

            <!-- +75% to +100% Table -->
            <div class="col-md-6 price-range-table">
              <div class="card">
                <div class="card-header bg-success text-white">
                  <h4>+75% to +100% Price Change</h4>
                </div>
                <div class="card-body">
                  <div class="table-responsive">
                    <table class="table table-striped table-hover">
                      <thead>
                      <tr>
                        <th>Symbol</th>
                        <th>Strike</th>
                        <th>Type</th>
                        <th>Role</th>
                        <th>PCR</th>
                        <th>Original LTP</th>
                        <th>Current LTP</th>
                        <th>Change %</th>
                        <th>Milestone</th>
                        <th>Lot Size</th>
                        <th>Live Bid</th>
                        <th>Live Ask</th>
                        <th>Status</th>
                      </tr>
                      </thead>
                      <tbody id="veryHighTableBody">
                      <!-- Very high range table rows will be added here -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- New Highlighted Options Section -->
  <!-- Color filter checkboxes for highlighted options -->
  <div class="row mb-2">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="d-flex align-items-center">
            <label class="me-3 mb-0"><strong>Filter by color:</strong></label>
            <div id="highlightedColorFilters" class="d-flex flex-wrap">
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="colorAll" value="all" checked>
                <label class="form-check-label" for="colorAll">All</label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="colorRed" value="red" checked>
                <label class="form-check-label" for="colorRed">
                  <span class="color-badge" style="background-color: rgba(255, 99, 132, 0.3);"></span> Red
                </label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="colorGreen" value="green" checked>
                <label class="form-check-label" for="colorGreen">
                  <span class="color-badge" style="background-color: rgba(75, 192, 192, 0.3);"></span> Green
                </label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="colorBlue" value="blue" checked>
                <label class="form-check-label" for="colorBlue">
                  <span class="color-badge" style="background-color: rgba(54, 162, 235, 0.3);"></span> Blue
                </label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="colorYellow" value="yellow" checked>
                <label class="form-check-label" for="colorYellow">
                  <span class="color-badge" style="background-color: rgba(255, 206, 86, 0.3);"></span> Yellow
                </label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="colorPurple" value="purple" checked>
                <label class="form-check-label" for="colorPurple">
                  <span class="color-badge" style="background-color: rgba(153, 102, 255, 0.3);"></span> Purple
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row mb-3">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-warning text-dark">
          <h4>Highlighted Options</h4>
          <p class="mb-0">Options that you have highlighted for tracking appear here</p>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-hover">
              <thead>
              <tr>
                <th>Symbol</th>
                <th>Strike</th>
                <th>Type</th>
                <th>Role</th>
                <th>PCR</th>
                <th>Days</th>
                <th>Time (IST)</th>
                <th>Original LTP</th>
                <th>Current LTP</th>
                <th class="sortable" data-sort="highlighted_change">Change %</th>
                <th>Status</th>
                <th>St Bid Qty</th>
                <th>St Ask Qty</th>
                <th>Live Bid</th>
                <th>Live Ask</th>
                <th>OI</th>
                <th>Volume</th>
                <th>Color</th>
              </tr>
              </thead>
              <tbody id="highlightedTableBody">
              <!-- Highlighted options will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row mb-3">
    <div class="col-12">
      <div class="data-view-tabs">
        <ul class="nav nav-tabs" id="dataViewTabs">
          <li class="nav-item">
            <a class="nav-link active" id="all-tab" data-view="all" href="#">All Trades</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" id="recovery-tab" data-view="recovery" href="#">Price Recovery</a>
          </li>
        </ul>
        <div class="pt-2">
                    <span id="categoryDescription" class="text-muted">
                        Showing all trades data. Select a category from the tabs to filter.
                    </span>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col-12">
      <div id="data-container">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
            <tr>
              <th class="sortable" data-sort="symbol">Symbol</th>
              <th>Strike</th>
              <th>Type</th>
              <th class="sortable" data-sort="role">Role</th>
              <th class="sortable" data-sort="daysCaptured">Days Captured</th>
              <th class="sortable" data-sort="timestamp">Time (IST)</th>
              <th>Original LTP</th>
              <th>Current LTP</th>
              <th class="sortable" data-sort="percent_change">Change %</th>
              <th class="sortable" data-sort="todays_return">Today's Return %</th>
              <th class="sortable" data-sort="milestone">Milestone</th>
              <th>Status</th>
              <th>Bid Qty</th>
              <th>Live Bid</th>
              <th>Live Ask</th>
              <th>Ask Qty</th>
              <th>OI</th>
              <th class="sortable" data-sort="oi_change">OI Change %</th>
              <th>Volume</th>
              <th class="sortable" data-sort="volume_change">Volume Change %</th>
              <th>IV</th>
              <th>IV Change</th>
              <th>Delta</th>
              <th>Delta Change</th>
              <th>Gamma</th>
              <th>Gamma Change</th>
              <th>Theta</th>
              <th>Theta Change</th>
              <th>Vega</th>
              <th>Vega Change</th>
              <th>POP</th>
              <th>PCR</th>
            </tr>
            </thead>
            <tbody id="dataTableBody">
            <!-- Table rows will be dynamically added here -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- New section for price recovery options -->
  <div class="row mt-5">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-success text-white">
          <h4>Price Recovery Options</h4>
          <p class="mb-0">Options that previously dropped below 25% or 50% of original price but have now recovered</p>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-hover">
              <thead>
              <tr>
                <th>Symbol</th>
                <th>Strike</th>
                <th>Type</th>
                <th>Role</th>
                <th>Days Captured</th>
                <th>Original LTP</th>
                <th>Current LTP</th>
                <th>Current Change %</th>
                <th>Lowest Milestone</th>  <!-- Add this line -->
                <th>Status</th>
                <th>Live Bid</th>
                <th>Live Ask</th>
                <th>OI</th>
                <th>Volume</th>
              </tr>
              </thead>
              <tbody id="recoveryTableBody">
              <!-- Recovery table rows will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Context menu for color highlighting -->
<div id="contextMenu" class="context-menu">
  <div class="context-menu-item" data-color="none">
    <span class="color-option" style="background-color: transparent; border: 1px solid #ccc;"></span>
    Remove Highlight
  </div>
  <div class="context-menu-item" data-color="red">
    <span class="color-option" style="background-color: rgba(255, 99, 132, 0.3);"></span>
    Red
  </div>
  <div class="context-menu-item" data-color="green">
    <span class="color-option" style="background-color: rgba(75, 192, 192, 0.3);"></span>
    Green
  </div>
  <div class="context-menu-item" data-color="blue">
    <span class="color-option" style="background-color: rgba(54, 162, 235, 0.3);"></span>
    Blue
  </div>
  <div class="context-menu-item" data-color="yellow">
    <span class="color-option" style="background-color: rgba(255, 206, 86, 0.3);"></span>
    Yellow
  </div>
  <div class="context-menu-item" data-color="purple">
    <span class="color-option" style="background-color: rgba(153, 102, 255, 0.3);"></span>
    Purple
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script>

  let activeColorFilters = {
  red: true,
  green: true,
  blue: true,
  yellow: true,
  purple: true
};

  // Add this to your DOMContentLoaded event listener:
document.querySelectorAll('#highlightedColorFilters input[type="checkbox"]').forEach(checkbox => {
  checkbox.addEventListener('change', function() {
      if (this.id === 'colorAll') {
          // Toggle all other checkboxes when "All" is clicked
          const isChecked = this.checked;
          document.querySelectorAll('#highlightedColorFilters input[type="checkbox"]:not(#colorAll)').forEach(cb => {
              cb.checked = isChecked;
              activeColorFilters[cb.value] = isChecked;
          });
      } else {
          // Update the specific color filter
          activeColorFilters[this.value] = this.checked;

          // Update "All" checkbox state based on other checkboxes
          const allChecked = Array.from(document.querySelectorAll('#highlightedColorFilters input[type="checkbox"]:not(#colorAll)'))
              .every(cb => cb.checked);
          document.getElementById('colorAll').checked = allChecked;
      }

      // Re-render the highlighted options table with new filters
      renderHighlightedOptionsTable();
  });
});

  // Force full-width on document load
  document.addEventListener('DOMContentLoaded', function() {
      // Override any template constraints
      document.querySelectorAll('.content-outer, .main-inner, .columns-inner, .post-body, .post-outer')
          .forEach(el => {
              if(el) {
                  el.style.width = '100%';
                  el.style.maxWidth = '100%';
                  el.style.padding = '0';
                  el.style.margin = '0';
              }
          });

      // Force container-fluid to full width
      document.querySelectorAll('.container-fluid').forEach(container => {
          container.style.width = '100%';
          container.style.maxWidth = '100%';
          container.style.paddingLeft = '15px';
          container.style.paddingRight = '15px';
          container.style.margin = '0';
      });

      // If Blogger template is used, these elements might exist
      if(document.querySelector('.post-body')) {
          document.querySelector('.post-body').style.transform = 'translateX(-15px)';
      }

      if(document.querySelector('.main-inner')) {
          document.querySelector('.main-inner').style.padding = '0';
      }

      if(document.querySelector('.columns-inner')) {
          document.querySelector('.columns-inner').style.padding = '0';
      }
  });

  // Global variables
  let allOrdersData = [];
  let currentSort = { column: null, direction: 'asc' };
  let activeFilters = ['open']; // Track multiple active filters
  let currentView = 'all';
  let highlightedOptions = {};
  let contextMenuTarget = null;
  let highlightedSort = { column: null, direction: 'asc' };

  // NEW global variables for date filtering
  let activeDateFilter = 0; // 0 = all time, 1 = 1 day, 2 = 2 days, etc.
  let customDateRange = { start: null, end: null };

  // NEW global variable for color filter on highlighted options
  let activeColorFilter = "all";

  // Set default sort for highlighted table to %change descending
  highlightedSort = { column: "percent_change", direction: "desc" };
  // Set default sort for all trades table to %change descending
  currentSort = { column: "percent_change", direction: "desc" };

  // List of index symbols to hide
  const indexSymbols = ['NIFTY', 'SENSEX', 'BANKNIFTY', 'FINNIFTY', 'MIDCPNIFTY', 'BANKEX'];

  // Function to check if a symbol is an index
  function isIndexSymbol(symbol) {
      if (!symbol) return false;
      return indexSymbols.some(index => symbol.toUpperCase().includes(index));
  }

  // Function to filter out index data
  function filterOutIndexData(data) {
      if (!data) return [];
      return data.filter(item => !isIndexSymbol(item.symbol));
  }

  // Base API URL - use explicit full URL with scheme
  const baseApiUrl = 'https://live-feed-azqo.onrender.com';

  // Initialize the page
  document.addEventListener('DOMContentLoaded', function() {

      // Load data
      fetchData();

      // Load highlighted options from session storage
      loadHighlightedOptions();

      // Set up refresh button
      document.getElementById('refreshBtn').addEventListener('click', fetchData);

      // Set up filter buttons to support multiple selections
      document.querySelectorAll('.filter-btn').forEach(btn => {
          btn.addEventListener('click', function() {
              const filter = this.dataset.filter;

              if (filter === 'all') {
                  // Clear all filters and only set 'all' active
                  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                  this.classList.add('active');
                  activeFilters = [];
              } else {
                  // Remove 'all' filter if it's active
                  document.querySelector('.filter-btn[data-filter="all"]').classList.remove('active');

                  // Toggle this filter
                  if (this.classList.contains('active')) {
                      this.classList.remove('active');
                      activeFilters = activeFilters.filter(f => f !== filter);

                      // If no filters are active, set 'all' active
                      if (activeFilters.length === 0) {
                          document.querySelector('.filter-btn[data-filter="all"]').classList.add('active');
                      }
                  } else {
                      this.classList.add('active');
                      activeFilters.push(filter);
                  }
              }

              applyFilters();
          });
      });

      // Set up Clear Filters button
      document.getElementById('clearFiltersBtn').addEventListener('click', function() {
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          document.querySelector('.filter-btn[data-filter="all"]').classList.add('active');
          activeFilters = [];
          applyFilters();
      });

      // Set up data view tabs
      document.querySelectorAll('#dataViewTabs .nav-link').forEach(tab => {
          tab.addEventListener('click', function(e) {
              e.preventDefault();

              // Remove active class from all tabs
              document.querySelectorAll('#dataViewTabs .nav-link').forEach(t => {
                  t.classList.remove('active');
              });

              // Add active class to clicked tab
              this.classList.add('active');

              // Update current view
              currentView = this.dataset.view;

              // Update description
              updateCategoryDescription(currentView);

              // Render the view
              renderCurrentView();
          });
      });

      // Set up sorting for table
      document.querySelectorAll('.sortable').forEach(header => {
          header.addEventListener('click', function() {
              const column = this.dataset.sort;

              // Toggle direction if clicking on the same column
              const direction = (column === currentSort.column && currentSort.direction === 'asc') ? 'desc' : 'asc';

              // Reset all headers
              document.querySelectorAll('.sortable').forEach(h => {
                  h.classList.remove('asc', 'desc');
              });

              // Mark current header
              this.classList.add(direction);

              // Update sort state
              currentSort = { column, direction };

              // Re-render with new sort
              renderCurrentView();
          });
      });

      // Set up context menu for option highlighting
      setupContextMenu();

      // Set up sorting for highlighted options table
      document.querySelector('.table-responsive .sortable[data-sort="highlighted_change"]')
          .addEventListener('click', function() {
              const column = "percent_change"; // The actual data property to sort by

              // Toggle direction if clicking on the same column
              const direction = (column === highlightedSort.column && highlightedSort.direction === 'asc')
                  ? 'desc' : 'asc';

              // Reset all headers in highlighted table
              document.querySelectorAll('.table-responsive .sortable').forEach(h => {
                  h.classList.remove('asc', 'desc');
              });

              // Mark current header
              this.classList.add(direction);

              // Update sort state for highlighted table
              highlightedSort = { column, direction };

              // Re-render highlighted table with new sort
              renderHighlightedOptionsTable();
          });

      // Close context menu when clicking elsewhere
      document.addEventListener('click', function(e) {
          const contextMenu = document.getElementById('contextMenu');
          if (contextMenu.style.display === 'block') {
              contextMenu.style.display = 'none';
          }
      });

      // Set up auto-refresh every 30 seconds
      setInterval(fetchData, 3000);

      // Setup highlighted options color filter buttons
      document.querySelectorAll('#highlightedColorFilter button').forEach(btn => {
          btn.addEventListener('click', function() {
              // Remove active class from all buttons in group
              document.querySelectorAll('#highlightedColorFilter button').forEach(b => b.classList.remove('active'));
              // Mark clicked button as active
              this.classList.add('active');
              activeColorFilter = this.dataset.color;
              renderHighlightedOptionsTable();
          });
      });
  });

  // Function to set up context menu
  function setupContextMenu() {
      // Add context menu listeners to all tables that show options
      const tables = ['dataTableBody', 'lowMediumTableBody', 'mediumHighTableBody',
                      'highTableBody', 'veryHighTableBody', 'recoveryTableBody', 'highlightedTableBody'];

      tables.forEach(tableId => {
          const table = document.getElementById(tableId);
          if (table) {
              table.addEventListener('contextmenu', showContextMenu);
          }
      });

      // Set up click handlers for context menu items
      const contextMenuItems = document.querySelectorAll('.context-menu-item');
      contextMenuItems.forEach(item => {
          item.addEventListener('click', handleContextMenuClick);
      });
  }

  // Function to show context menu
  function showContextMenu(e) {
      e.preventDefault();

      // Find the closest tr element (the row that was right-clicked)
      let target = e.target;
      while (target && target.tagName !== 'TR') {
          target = target.parentElement;
      }

      if (!target || !target.cells || target.cells.length < 3) return;

      // Extract option info from the row
      // Use textContent for strike and type, but handle symbol specially
      const symbolCell = target.cells[0];
      let symbol = symbolCell.textContent;

      // Clean the symbol if it contains any badge text
      if (symbol.includes('Recovery') || symbol.includes('Also in')) {
          // Extract just the symbol part before any badge
          symbol = symbol.split(' ')[0];
      }

      const strike = target.cells[1].textContent;
      const type = target.cells[2].textContent;

      // Create a unique key for this option
      const optionKey = `${symbol}-${strike}-${type}`;
      contextMenuTarget = { element: target, key: optionKey };

      // Position and show the context menu
      const contextMenu = document.getElementById('contextMenu');
      contextMenu.style.left = e.pageX + 'px';
      contextMenu.style.top = e.pageY + 'px';
      contextMenu.style.display = 'block';

      // Stop the event from propagating to prevent immediate closing
      e.stopPropagation();
  }


  // Function to handle context menu item clicks
  function handleContextMenuClick(e) {
      e.stopPropagation();

      if (!contextMenuTarget) return;

      const color = this.dataset.color;
      const optionKey = contextMenuTarget.key;

      // Remove all existing highlight classes
      const highlightClasses = ['highlight-red', 'highlight-green', 'highlight-blue',
                               'highlight-yellow', 'highlight-purple'];

      if (color === 'none') {
          // Remove this option from highlighted options
          delete highlightedOptions[optionKey];
      } else {
          // Add or update this option in highlighted options
          highlightedOptions[optionKey] = color;
      }

      // Save to session storage
      saveHighlightedOptions();

      // Apply the highlighting to all instances of this option in all tables
      applyHighlightingToAllTables();

      // Render highlighted options table
      renderHighlightedOptionsTable();

      // Hide the context menu
      document.getElementById('contextMenu').style.display = 'none';
  }

  // Function to save highlighted options to local storage
  function saveHighlightedOptions() {
      localStorage.setItem('highlightedOptions', JSON.stringify(highlightedOptions));
  }

  // Function to load highlighted options from local storage
  function loadHighlightedOptions() {
      const saved = localStorage.getItem('highlightedOptions');
      if (saved) {
          highlightedOptions = JSON.parse(saved);
          renderHighlightedOptionsTable();
      }
  }

  // Function to apply highlighting to all tables
  function applyHighlightingToAllTables() {
      const tables = ['dataTableBody', 'lowMediumTableBody', 'mediumHighTableBody',
                     'highTableBody', 'veryHighTableBody', 'recoveryTableBody'];

      tables.forEach(tableId => {
          const table = document.getElementById(tableId);
          if (table) {
              applyHighlightingToTable(table);
          }
      });
  }

  // Function to apply highlighting to a specific table
  function applyHighlightingToTable(table) {
      const rows = table.querySelectorAll('tr');

      rows.forEach(row => {
          if (!row.cells || row.cells.length < 3) return;

          const symbol = row.cells[0].textContent;
          const strike = row.cells[1].textContent;
          const type = row.cells[2].textContent;
          const optionKey = `${symbol}-${strike}-${type}`;

          // Remove all existing highlight classes
          const highlightClasses = ['highlight-red', 'highlight-green', 'highlight-blue',
                                   'highlight-yellow', 'highlight-purple'];
          highlightClasses.forEach(cls => row.classList.remove(cls));

          // Custom green highlight logic
          // Find the order in allOrdersData
          const order = allOrdersData.find(o => `${o.symbol}-${o.strike_price}-${o.option_type}` === optionKey);
          if (order && order.is_greater_than_50pct && !order.is_greater_than_75pct && order.percent_change < 25 && order.percent_change > -10) {
              row.classList.add('highlight-green');
              // Add to highlightedOptions if not already present
              if (!highlightedOptions[optionKey]) {
                  highlightedOptions[optionKey] = 'green';
                  saveHighlightedOptions();
              }
          } else if (highlightedOptions[optionKey]) {
              row.classList.add(`highlight-${highlightedOptions[optionKey]}`);
          }
      });
  }

  // Modified function to render highlighted options table with latest data
// Modified function to render highlighted options table with latest data
function renderHighlightedOptionsTable() {
  const tableBody = document.getElementById('highlightedTableBody');
  if (!tableBody) {
      console.error('Highlighted options table body not found');
      return;
  }
  tableBody.innerHTML = '';

  const highlightedKeys = Object.keys(highlightedOptions);
  if (highlightedKeys.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="16" class="text-center">No options are currently highlighted. Right-click on an option to highlight it.</td>`;
      tableBody.appendChild(emptyRow);
      return;
  }

  // This ensures we're using the latest data from the API
  let highlightedData = allOrdersData.filter(order => {
      const key = `${order.symbol}-${order.strike_price}-${order.option_type}`;
      const color = highlightedOptions[key];
      return highlightedKeys.includes(key) && activeColorFilters[color];
  });

  // Apply active filters if any
  if (activeFilters.length > 0) {
      highlightedData = filterDataByActiveFilters(highlightedData);
  }

  if (highlightedData.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="16" class="text-center">No highlighted options match the current filters</td>`;
      tableBody.appendChild(emptyRow);
      return;
  }

  // Sort the data if a sort column is set
  if (highlightedSort.column) {
      highlightedData.sort((a, b) => {
          let aValue = a[highlightedSort.column] === null ? 0 : a[highlightedSort.column];
          let bValue = b[highlightedSort.column] === null ? 0 : b[highlightedSort.column];

          if (typeof aValue === 'string' && typeof bValue === 'string') {
              return highlightedSort.direction === 'asc'
                  ? aValue.localeCompare(bValue)
                  : bValue.localeCompare(aValue);
          }
          return highlightedSort.direction === 'asc'
              ? aValue - bValue
              : bValue - aValue;
      });
  } else {
      // Default sort by symbol and strike
      highlightedData.sort((a, b) => {
          if (a.symbol !== b.symbol) {
              return a.symbol.localeCompare(b.symbol);
          }
          return a.strike_price - b.strike_price;
      });
  }

  // Render each highlighted option with the latest data
  highlightedData.forEach(order => {
      const row = document.createElement('tr');
      const optionKey = `${order.symbol}-${order.strike_price}-${order.option_type}`;
      const color = highlightedOptions[optionKey];

      // Add the highlight class to the row
      row.classList.add(`highlight-${color}`);

      // Add data attribute to easily identify this row
      row.dataset.optionKey = optionKey;

      // Format status with appropriate CSS class
      const statusClass = order.status === 'Done' ? 'status-done' : 'status-open';
      const statusDisplay = `<span class="${statusClass}">${order.status}</span>`;

      // Handle null or undefined values safely
      const safeValue = (value, defaultValue = 0) => {
          return (value === null || value === undefined) ? defaultValue : value;
      };

      // Get values with safe defaults
      const currentLtp = safeValue(order.current_ltp);
      const storedLtp = safeValue(order.stored_ltp);
      const percentChange = safeValue(order.percent_change);
      const todaysReturn = safeValue(order.todays_return);
      const daysCaptured = order.daysCaptured || 'N/A';

      const bidQ = formatLargeNumber(order.stored_bidq || 0);
      const askQ = formatLargeNumber(order.stored_askq || 0);

          // Get live bid and ask data

          const liveBidQ = safeValue(order.bidQ);
          const liveAskQ = safeValue(order.askQ);

          // Format live bid and ask quantities
          const liveBidQDisplay = formatLargeNumber(liveBidQ);
          const liveAskQDisplay = formatLargeNumber(liveAskQ);

          // Check if bid or ask quantities exceed threshold
          const lotSize = order.lot_size || 1;
          const highBidQty = liveBidQ > (50 * lotSize);
          const highAskQty = liveAskQ > (50 * lotSize);



      // Format bid and ask with highlighting if needed
      const bidQtyClass = highBidQty ? 'high-quantity' : '';
      const askQtyClass = highAskQty ? 'high-quantity' : '';

      // Create a color indicator display
      const colorDisplay = `<span class="badge" style="background-color: rgba(${getColorRGB(color)}, 0.7);">${color.charAt(0).toUpperCase() + color.slice(1)}</span>`;

      if (highBidQty || highAskQty) {
          row.classList.add('high-qty-row');
      }

      row.innerHTML = `
          <td>${order.symbol}</td>
          <td>${order.strike_price}</td>
          <td>${order.option_type}</td>
          <td>${order.role || 'Unknown'}</td>
          <td>${formatLargeNumber(order.pcr || 0)}</td>
          <td>${daysCaptured}</td>
          <td>${formatISTTime(order.timestamp)}</td>
          <td>${storedLtp.toFixed(2)}</td>
          <td>${currentLtp.toFixed(2)}</td>
          <td class="${percentChange > 0 ? 'profit' : 'loss'}">${percentChange.toFixed(2)}%</td>
          <td class="${todaysReturn > 0 ? 'profit' : 'loss'}">${todaysReturn.toFixed(2)}%</td>
          <td>${statusDisplay}</td>
          <td class="${bidQtyClass}">${bidQ}</td>
          <td class="${askQtyClass}">${askQ}</td>
          <td class="live-data">${liveBidQDisplay}</td>
          <td class="live-data">${liveAskQDisplay}</td>
          <td>${formatLargeNumber(order.oi || 0)}</td>
          <td>${formatLargeNumber(order.volume || 0)}</td>
          <td>${colorDisplay}</td>
      `;

      tableBody.appendChild(row);
  });
}

  // Helper function to get RGB values for a color name
  function getColorRGB(color) {
      switch(color) {
          case 'red':
              return '255, 99, 132';
          case 'green':
              return '75, 192, 192';
          case 'blue':
              return '54, 162, 235';
          case 'yellow':
              return '255, 206, 86';
          case 'purple':
              return '153, 102, 255';
          default:
              return '128, 128, 128';
      }
  }



  function updateCategoryDescription(viewType) {
      let description = '';
      switch(viewType) {
          case 'all':
              description = 'Showing all trades data.';
              break;
          case 'higher':
              description = 'Showing trades with price increases only.';
              break;
          case 'lower':
              description = 'Showing trades with price decreases only.';
              break;
          case 'moderate':
              description = 'Showing trades with moderate price changes (between -25% and +25%).';
              break;
          case 'zero-to-ten':
              description = 'Showing trades with small price increases (between 0% and +10%).';
              break;
          case 'low-medium':
              description = 'Showing trades with lower-medium price increases (between +10% and +25%).';
              break;
          case 'medium-high':
              description = 'Showing trades with significant price increases (between +25% and +50%).';
              break;
          case 'high':
              description = 'Showing trades with large price increases (between +50% and +75%).';
              break;
          case 'very-high':
              description = 'Showing trades with very large price increases (between +75% and +100%).';
              break;
          case 'recovery':
              description = 'Showing trades that previously dropped below 50% or 25% of stored price but have now recovered to equal or exceed the original price.';
              break;
      }
      document.getElementById('categoryDescription').textContent = description;
  }

  // Updated function to process options orders analysis data
  async function fetchData() {
      try {
          // Use full URL with scheme
          const response = await fetch(`${baseApiUrl}/api/options-orders-analysis`);
          const data = await response.json();

          if (data && data.data) {
              // Process the data to add buyer/seller information and days captured
              allOrdersData = data.data.map(order => {
                  // Determine if this is a buyer or seller based on bidQ/askQ comparison
                  const bidQ = order.stored_bidq || 0;
                  const askQ = order.stored_askq || 0;
                  const role = bidQ > askQ ? 'Buyer' : 'Seller';

                  // Calculate days since capture
                  const daysCaptured = calculateDaysCaptured(order.timestamp);

                  // Calculate Greek changes
                  const ivChange = calculateChange(order.iv, order.original_iv);
                  const deltaChange = calculateChange(order.delta, order.original_delta);
                  const gammaChange = calculateChange(order.gamma, order.original_gamma);
                  const thetaChange = calculateChange(order.theta, order.original_theta);
                  const vegaChange = calculateChange(order.vega, order.original_vega);

                  // Calculate OI and Volume changes
                  const oiChange = calculateChange(order.oi, order.original_oi);
                  const volumeChange = calculateChange(order.volume, order.original_volume);

                  // Ensure percent_change is correctly calculated if not provided
                  let percentChange = order.percent_change;
                  if (percentChange === undefined || percentChange === null) {
                      percentChange = calculateChange(order.current_ltp, order.stored_ltp);
                  }

                  // Calculate if this is a recovery candidate
                  // First, determine the lowest point the price has reached
                  let lowestPoint = Infinity;

                  if (order.lowest_point !== undefined && order.lowest_point !== null) {
                      lowestPoint = order.lowest_point;
                  } else if (order.min_ltp !== undefined && order.min_ltp !== null) {
                      lowestPoint = order.min_ltp;
                  }

                  // If we still don't have a lowest point, use current LTP if it's lower than stored
                  if (lowestPoint === Infinity && order.current_ltp < order.stored_ltp) {
                      lowestPoint = order.current_ltp;
                  }

                  // Convert Infinity to null for proper JSON handling
                  if (lowestPoint === Infinity) {
                      lowestPoint = null;
                  }

                  // Determine if price has ever been below thresholds
                  const isLessThan50pct = order.is_less_than_50pct ||
                                         (lowestPoint !== null && lowestPoint < order.stored_ltp * 0.5);

                  const isLessThan25pct = order.is_less_than_25pct ||
                                         (lowestPoint !== null && lowestPoint < order.stored_ltp * 0.25);

                  // Get lot size for this instrument if available
                  let lot_size = 1;
                  // Try to get lot size for this instrument - we'll fetch this for price range tables
                  if (order.instrument_key) {
                      // We'll use the existing trading_instruments endpoint to get lot size
                      fetch(`${baseApiUrl}/api/trading_instruments?symbol=${order.symbol}`)
                          .then(response => response.json())
                          .then(instrumentData => {
                              if (instrumentData && instrumentData.lot_size) {
                                  order.lot_size = instrumentData.lot_size;
                                  // Re-render price range tables when lot size is updated
                                  renderPriceRangeTables();
                              }
                          })
                          .catch(error => console.error(`Error fetching lot size for ${order.symbol}:`, error));
                  }

                  return {
                      ...order,
                      role,
                      daysCaptured,
                      ivChange,
                      deltaChange,
                      gammaChange,
                      thetaChange,
                      vegaChange,
                      oiChange,
                      volumeChange,
                      percent_change: percentChange,
                      is_less_than_50pct: isLessThan50pct,
                      is_less_than_25pct: isLessThan25pct,
                      lowest_point: lowestPoint,
                      lot_size: order.lot_size || lot_size
                  };
              });

              // Filter out index data
              allOrdersData = filterOutIndexData(allOrdersData);

              console.log("Fetched data:", allOrdersData);  // Debug log

              // Check if we have data before rendering
              if (allOrdersData.length === 0) {
                  console.warn("No data received from API");
                  document.getElementById('lastUpdated').textContent = new Date().toLocaleString() + " (No data)";
                  return;
              }

              renderCurrentView();
              updateStats(); // Make sure this is called after data is processed

              renderHighlightedOptionsTable();
              renderPriceRangeTables(); // Apply current filters to price range tables
              renderRecoveryTable(); // Apply current filters to recovery table
              document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
          } else {
              console.warn("API response missing data property or is empty", data);
              document.getElementById('lastUpdated').textContent = new Date().toLocaleString() + " (Empty response)";
          }
      } catch (error) {
          console.error('Error fetching data:', error);
          document.getElementById('lastUpdated').textContent = new Date().toLocaleString() + " (Error)";
          // Don't show alert as it might be disruptive with auto-refresh
          console.error('Error loading data. Please try again.');
      }
  }

  // Function to render price range tables
  function renderPriceRangeTables() {
      // Apply active filters before filtering by price range
      let filteredData = filterDataByActiveFilters(allOrdersData);

      // Ensure index data is filtered out
      filteredData = filterOutIndexData(filteredData);

      // Filter data for +10% to +25% price change
      const lowMediumData = filteredData.filter(order =>
          order.percent_change > 10 && order.percent_change <= 25
      );

      // Filter data for +25% to +50% price change
      const mediumHighData = filteredData.filter(order =>
          order.percent_change > 25 && order.percent_change <= 50
      );

      // Filter data for +50% to +75% price change
      const highData = filteredData.filter(order =>
          order.percent_change > 50 && order.percent_change <= 75
      );

      // Filter data for +75% to +100% price change
      const veryHighData = filteredData.filter(order =>
          order.percent_change > 75 && order.percent_change <= 100
      );

      // Sort data by percent_change in descending order
      const sortedLowMediumData = [...lowMediumData].sort((a, b) => b.percent_change - a.percent_change);
      const sortedMediumHighData = [...mediumHighData].sort((a, b) => b.percent_change - a.percent_change);
      const sortedHighData = [...highData].sort((a, b) => b.percent_change - a.percent_change);
      const sortedVeryHighData = [...veryHighData].sort((a, b) => b.percent_change - a.percentChange);

      // Render tables with live bid/ask data
      renderPriceRangeTable(sortedLowMediumData, 'lowMediumTableBody');
      renderPriceRangeTable(sortedMediumHighData, 'mediumHighTableBody');
      renderPriceRangeTable(sortedHighData, 'highTableBody');
      renderPriceRangeTable(sortedVeryHighData, 'veryHighTableBody');
  }

 // Modified function to render price range table without index
  function renderPriceRangeTable(data, tableId) {
      const tableBody = document.getElementById(tableId);
      if (!tableBody) {
          console.error(`Table body with id ${tableId} not found`);
          return;
      }

      tableBody.innerHTML = '';

      if (data.length === 0) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = `<td colspan="11" class="text-center">No data available</td>`;
          tableBody.appendChild(emptyRow);
          return;
      }

      // Create a map of symbols from recovery table
      const recoverySymbols = new Set();

      // Get recovery data - options that dropped below thresholds but now have recovered
      const recoveryData = filterOutIndexData(allOrdersData).filter(order => {
          const hasDroppedBelow = order.is_less_than_25pct || order.is_less_than_50pct;
          const hasRecovered = order.current_ltp >= order.stored_ltp;
          return hasDroppedBelow && hasRecovered;
      });

      // Add all recovery symbols to the set
      recoveryData.forEach(order => {
          recoverySymbols.add(order.symbol);
      });

      data.forEach(order => {
          const row = document.createElement('tr');

          // Check if this option is highlighted
          const optionKey = `${order.symbol}-${order.strike_price}-${order.option_type}`;
          if (highlightedOptions[optionKey]) {
              row.classList.add(`highlight-${highlightedOptions[optionKey]}`);
          }

          // Format status with appropriate CSS class
          const statusClass = order.status === 'Done' ? 'status-done' : 'status-open';
          const statusDisplay = `<span class="${statusClass}">${order.status}</span>`;

          // Ensure values are safe
          const storedLtp = order.stored_ltp || 0;
          const currentLtp = order.current_ltp || 0;
          const percentChange = order.percent_change || 0;
          const lotSize = order.lot_size || 1;

          // Get live bid and ask quantities
          const liveBidQ = order.bidQ || 0;
          const liveAskQ = order.askQ || 0;

          // Check if bid or ask quantities exceed 50 * lot size
          const highBidQty = liveBidQ > (50 * lotSize);
          const highAskQty = liveAskQ > (50 * lotSize);

          // Format bid and ask with highlighting if needed
          const bidQtyClass = highBidQty ? 'high-quantity' : '';
          const askQtyClass = highAskQty ? 'high-quantity' : '';

          const bidQtyDisplay = formatLargeNumber(liveBidQ);
          const askQtyDisplay = formatLargeNumber(liveAskQ);

          // Check if this symbol is also in recovery table and add badge if needed
          let symbolDisplay = order.symbol;
          if (recoverySymbols.has(order.symbol)) {
              symbolDisplay = `<span class="recovery-overlap">${order.symbol} <span class="badge bg-success">Recovery</span></span>`;
          }

          // Determine milestone based on percentage change
          let milestoneText = 'New';
          let milestoneClass = 'milestone-new';
          if (order.is_greater_than_75pct) {
              milestoneText = '4th table';
              milestoneClass = 'milestone-75';
          } else if (order.is_greater_than_50pct) {
              milestoneText = '3rd table';
              milestoneClass = 'milestone-50';
          } else if (order.is_greater_than_25pct) {
              milestoneText = '2nd table';
              milestoneClass = 'milestone-25';
          }
          const milestone = `<span class="milestone-badge ${milestoneClass}">${milestoneText}</span>`;

          if (highBidQty || highAskQty) {
             row.classList.add('high-qty-row');
           }

          row.innerHTML = `
              <td>${symbolDisplay}</td>
              <td>${order.strike_price}</td>
              <td>${order.option_type}</td>
              <td>${order.role || 'Unknown'}</td>
              <td>${order.pcr.toFixed(2)}</td>
              <td>${storedLtp.toFixed(2)}</td>
              <td>${currentLtp.toFixed(2)}</td>
              <td class="profit">+${percentChange.toFixed(2)}%</td>
              <td>${milestone}</td>
              <td>${statusDisplay}</td>
              <td class="live-data ${bidQtyClass}">${bidQtyDisplay}</td>
              <td class="live-data ${askQtyClass}">${askQtyDisplay}</td>
              <td>${formatLargeNumber(order.oi || 0)}</td>
              <td>${formatLargeNumber(order.volume || 0)}</td>
          `;

          tableBody.appendChild(row);
      });

      // Apply highlighting to the table after rendering
      applyHighlightingToTable(tableBody);
  }

  function renderCurrentView() {
      let filteredData = filterDataByActiveFilters(allOrdersData);

      // Ensure index data is filtered out
      filteredData = filterOutIndexData(filteredData);

      // Apply view-specific filtering
      switch(currentView) {
          case 'higher':
              filteredData = filteredData.filter(order => order.percent_change > 0);
              break;
          case 'lower':
              filteredData = filteredData.filter(order => order.percent_change < 0);
              break;
          case 'moderate':
              filteredData = filteredData.filter(order =>
                  (order.percent_change >= -25 && order.percent_change <= 25)
              );
              break;
          case 'zero-to-ten':
              filteredData = filteredData.filter(order =>
                  (order.percent_change >= 0 && order.percent_change <= 10)
              );
              break;
          case 'low-medium':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 10 && order.percent_change <= 25)
              );
              break;
          case 'medium-high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 25 && order.percent_change <= 50)
              );
              break;
          case 'high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 50 && order.percent_change <= 75)
              );
              break;
          case 'very-high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 75 && order.percent_change <= 100)
              );
              break;
          case 'recovery':
              filteredData = filteredData.filter(order => {
                  // Check if recovery flags exist or determine them based on lowest point data
                  const hasBeenLow = order.is_less_than_25pct || order.is_less_than_50pct ||
                                    (order.lowest_point && order.lowest_point < order.stored_ltp * 0.5);

                  // Check if current price has recovered to equal or above original price
                  const hasRecovered = order.current_ltp >= order.stored_ltp;

                  return hasBeenLow && hasRecovered;
              });
              break;
      }

      // Apply sorting
      const sortedData = applySort(filteredData);

      // Render the table
      renderTable(sortedData, 'dataTableBody');


      // Also update the price range tables and recovery table
      renderPriceRangeTables();
      renderRecoveryTable();
  }

  function calculateDaysCaptured(timestamp) {
      if (!timestamp) return 'N/A';

      const captureDate = new Date(timestamp);
      const currentDate = new Date();
      const diffTime = Math.abs(currentDate - captureDate);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      return diffDays;
  }

  // Convert UTC timestamp to IST time format (DD, HH:MM)
  function formatISTTime(timestamp) {
      if (!timestamp) return 'N/A';

      // Create a date object from the timestamp
      const date = new Date(timestamp);

      // IST is UTC+5:30, so add 5 hours and 30 minutes to UTC time
      const istDate = new Date(date.getTime() + (5 * 60 + 30) * 60000);

      // Format time as DD, HH:MM
      const day = istDate.getUTCDate().toString().padStart(2, '0');
      const hours = istDate.getUTCHours().toString().padStart(2, '0');
      const minutes = istDate.getUTCMinutes().toString().padStart(2, '0');

      return `${day}, ${hours}:${minutes}`;
  }

  function calculateChange(currentValue, originalValue) {
      if (currentValue === null || originalValue === null) return null;
      if (originalValue === 0) return currentValue;

      return ((currentValue - originalValue) / Math.abs(originalValue)) * 100;
  }

  function renderTable(data, tableId) {
      const tableBody = document.getElementById(tableId);
      if (!tableBody) {
          console.error(`Table body with id ${tableId} not found`);
          return;
      }

      tableBody.innerHTML = '';

      console.log(`Rendering ${data.length} rows to ${tableId}`);  // Debug log

      if (data.length === 0) {
          // Add a row indicating no data
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = `<td colspan="29" class="text-center">No data available</td>`;
          tableBody.appendChild(emptyRow);
          return;
      }

      data.forEach((order, index) => {
          const row = document.createElement('tr');

          // Don't add any row index/number to the row

          // Add class based on performance

          // Check if this option is highlighted
          const optionKey = `${order.symbol}-${order.strike_price}-${order.option_type}`;
          if (highlightedOptions[optionKey]) {
              row.classList.add(`highlight-${highlightedOptions[optionKey]}`);
          }

          // Format greek changes with + or - sign and % symbol
          const formatGreekChange = (change) => {
              if (change === null || change === undefined) return 'N/A';
              const sign = change > 0 ? '+' : '';
              return `${sign}${change.toFixed(2)}%`;
          };

          // Handle null or undefined values safely
          const safeValue = (value, defaultValue = 0) => {
              return (value === null || value === undefined) ? defaultValue : value;
          };

          // Add check for null values
          const currentLtp = safeValue(order.current_ltp);
          const storedLtp = safeValue(order.stored_ltp);
          const prevClose = safeValue(order.prev_close);
          const percentChange = safeValue(order.percent_change);
          let todaysReturn = 0;
          if (prevClose > 0) {
              todaysReturn = ((currentLtp - prevClose) / prevClose) * 100;
          }
          order.todays_return = todaysReturn;

          // Format the status with appropriate CSS class
          const statusClass = order.status === 'Done' ? 'status-done' : 'status-open';
          const statusDisplay = `<span class="${statusClass}">${order.status}</span>`;

          // Format bid and ask quantities (convert to K or M for readability)
          const bidQ = formatLargeNumber(order.stored_bidq || 0);
          const askQ = formatLargeNumber(order.stored_askq || 0);

          // Get live bid and ask data
          const liveBid = safeValue(order.bid);
          const liveAsk = safeValue(order.ask);
          const liveBidQ = safeValue(order.bidQ);
          const liveAskQ = safeValue(order.askQ);

          // Format live bid and ask quantities
          const liveBidQDisplay = formatLargeNumber(liveBidQ);
          const liveAskQDisplay = formatLargeNumber(liveAskQ);

          // Check if bid or ask quantities exceed threshold
          const lotSize = order.lot_size || 1;
          const highBidQty = liveBidQ > ( (50 * lotSize) + liveAskQ );
          const highAskQty = liveAskQ > ( (50 * lotSize) + liveBidQ );

          // Format bid and ask with highlighting if needed
          const bidQtyClass = highBidQty ? 'high-quantity' : '';
          const askQtyClass = highAskQty ? 'high-quantity' : '';

          // Display symbol without any special highlighting
          const symbolDisplay = order.symbol;

          // Determine milestone based on percentage change
          let milestoneText = 'New';
          let milestoneClass = 'milestone-new';
          if (order.is_greater_than_75pct) {
              milestoneText = '4th table';
              milestoneClass = 'milestone-75';
          } else if (order.is_greater_than_50pct) {
              milestoneText = '3rd table';
              milestoneClass = 'milestone-50';
          } else if (order.is_greater_than_25pct) {
              milestoneText = '2nd table';
              milestoneClass = 'milestone-25';
          }
          const milestone = `<span class="milestone-badge ${milestoneClass}">${milestoneText}</span>`;

          if (highBidQty || highAskQty) {
              row.classList.add('high-qty-row');
          }

          row.innerHTML = `
              <td>${symbolDisplay}</td>
              <td>${order.strike_price}</td>
              <td>${order.option_type}</td>
              <td>${order.role || 'Unknown'}</td>
              <td>${order.daysCaptured || 'N/A'}</td>
              <td>${formatISTTime(order.timestamp)}</td>
              <td>${storedLtp.toFixed(2)}</td>
              <td>${currentLtp.toFixed(2)}</td>
              <td class="${percentChange > 0 ? 'profit' : 'loss'}">${percentChange.toFixed(2)}%</td>
              <td class="${todaysReturn > 0 ? 'profit' : 'loss'}">${todaysReturn.toFixed(2)}%</td>
              <td>${milestone}</td>
              <td>${statusDisplay}</td>
              <td class="${bidQtyClass}">${bidQ}</td>
              <td class="live-data">${liveBidQDisplay}</td>
              <td class="live-data">${liveAskQDisplay}</td>
              <td class="${askQtyClass}">${askQ}</td>
              <td>${formatLargeNumber(order.oi)}</td>
              <td class="${order.oi_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.oi_change)}</td>
              <td>${formatLargeNumber(order.volume)}</td>
              <td class="${order.volume_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.volume_change)}</td>
              <td>${order.iv ? order.iv.toFixed(2) + '%' : 'N/A'}</td>
              <td class="${order.iv_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.iv_change)}</td>
              <td>${order.delta ? order.delta.toFixed(2) : 'N/A'}</td>
              <td class="${order.delta_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.delta_change)}</td>
              <td>${order.gamma ? order.gamma.toFixed(4) : 'N/A'}</td>
              <td class="${order.gamma_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.gamma_change)}</td>
              <td>${order.theta ? order.theta.toFixed(2) : 'N/A'}</td>
              <td class="${order.theta_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.theta_change)}</td>
              <td>${order.vega ? order.vega.toFixed(2) : 'N/A'}</td>
              <td class="${order.vega_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.vega_change)}</td>
              <td>${order.pop ? order.pop.toFixed(2) + '%' : 'N/A'}</td>
              <td>${order.pcr ? order.pcr.toFixed(2) : 'N/A'}</td>
          `;

          tableBody.appendChild(row);
  });
}

  // Helper function to get RGB values for a color name
  function getColorRGB(color) {
      switch(color) {
          case 'red':
              return '255, 99, 132';
          case 'green':
              return '75, 192, 192';
          case 'blue':
              return '54, 162, 235';
          case 'yellow':
              return '255, 206, 86';
          case 'purple':
              return '153, 102, 255';
          default:
              return '128, 128, 128';
      }
  }



  function updateCategoryDescription(viewType) {
      let description = '';
      switch(viewType) {
          case 'all':
              description = 'Showing all trades data.';
              break;
          case 'higher':
              description = 'Showing trades with price increases only.';
              break;
          case 'lower':
              description = 'Showing trades with price decreases only.';
              break;
          case 'moderate':
              description = 'Showing trades with moderate price changes (between -25% and +25%).';
              break;
          case 'zero-to-ten':
              description = 'Showing trades with small price increases (between 0% and +10%).';
              break;
          case 'low-medium':
              description = 'Showing trades with lower-medium price increases (between +10% and +25%).';
              break;
          case 'medium-high':
              description = 'Showing trades with significant price increases (between +25% and +50%).';
              break;
          case 'high':
              description = 'Showing trades with large price increases (between +50% and +75%).';
              break;
          case 'very-high':
              description = 'Showing trades with very large price increases (between +75% and +100%).';
              break;
          case 'recovery':
              description = 'Showing trades that previously dropped below 50% or 25% of stored price but have now recovered to equal or exceed the original price.';
              break;
      }
      document.getElementById('categoryDescription').textContent = description;
  }

  // Updated function to process options orders analysis data
  async function fetchData() {
      try {
          // Use full URL with scheme
          const response = await fetch(`${baseApiUrl}/api/options-orders-analysis`);
          const data = await response.json();

          if (data && data.data) {
              // Process the data to add buyer/seller information and days captured
              allOrdersData = data.data.map(order => {
                  // Determine if this is a buyer or seller based on bidQ/askQ comparison
                  const bidQ = order.stored_bidq || 0;
                  const askQ = order.stored_askq || 0;
                  const role = bidQ > askQ ? 'Buyer' : 'Seller';

                  // Calculate days since capture
                  const daysCaptured = calculateDaysCaptured(order.timestamp);

                  // Calculate Greek changes
                  const ivChange = calculateChange(order.iv, order.original_iv);
                  const deltaChange = calculateChange(order.delta, order.original_delta);
                  const gammaChange = calculateChange(order.gamma, order.original_gamma);
                  const thetaChange = calculateChange(order.theta, order.original_theta);
                  const vegaChange = calculateChange(order.vega, order.original_vega);

                  // Calculate OI and Volume changes
                  const oiChange = calculateChange(order.oi, order.original_oi);
                  const volumeChange = calculateChange(order.volume, order.original_volume);

                  // Ensure percent_change is correctly calculated if not provided
                  let percentChange = order.percent_change;
                  if (percentChange === undefined || percentChange === null) {
                      percentChange = calculateChange(order.current_ltp, order.stored_ltp);
                  }

                  // Calculate if this is a recovery candidate
                  // First, determine the lowest point the price has reached
                  let lowestPoint = Infinity;

                  if (order.lowest_point !== undefined && order.lowest_point !== null) {
                      lowestPoint = order.lowest_point;
                  } else if (order.min_ltp !== undefined && order.min_ltp !== null) {
                      lowestPoint = order.min_ltp;
                  }

                  // If we still don't have a lowest point, use current LTP if it's lower than stored
                  if (lowestPoint === Infinity && order.current_ltp < order.stored_ltp) {
                      lowestPoint = order.current_ltp;
                  }

                  // Convert Infinity to null for proper JSON handling
                  if (lowestPoint === Infinity) {
                      lowestPoint = null;
                  }

                  // Determine if price has ever been below thresholds
                  const isLessThan50pct = order.is_less_than_50pct ||
                                         (lowestPoint !== null && lowestPoint < order.stored_ltp * 0.5);

                  const isLessThan25pct = order.is_less_than_25pct ||
                                         (lowestPoint !== null && lowestPoint < order.stored_ltp * 0.25);

                  // Get lot size for this instrument if available
                  let lot_size = 1;
                  // Try to get lot size for this instrument - we'll fetch this for price range tables
                  if (order.instrument_key) {
                      // We'll use the existing trading_instruments endpoint to get lot size
                      fetch(`${baseApiUrl}/api/trading_instruments?symbol=${order.symbol}`)
                          .then(response => response.json())
                          .then(instrumentData => {
                              if (instrumentData && instrumentData.lot_size) {
                                  order.lot_size = instrumentData.lot_size;
                                  // Re-render price range tables when lot size is updated
                                  renderPriceRangeTables();
                              }
                          })
                          .catch(error => console.error(`Error fetching lot size for ${order.symbol}:`, error));
                  }

                  return {
                      ...order,
                      role,
                      daysCaptured,
                      ivChange,
                      deltaChange,
                      gammaChange,
                      thetaChange,
                      vegaChange,
                      oiChange,
                      volumeChange,
                      percent_change: percentChange,
                      is_less_than_50pct: isLessThan50pct,
                      is_less_than_25pct: isLessThan25pct,
                      lowest_point: lowestPoint,
                      lot_size: order.lot_size || lot_size
                  };
              });

              // Filter out index data
              allOrdersData = filterOutIndexData(allOrdersData);

              console.log("Fetched data:", allOrdersData);  // Debug log

              // Check if we have data before rendering
              if (allOrdersData.length === 0) {
                  console.warn("No data received from API");
                  document.getElementById('lastUpdated').textContent = new Date().toLocaleString() + " (No data)";
                  return;
              }

              renderCurrentView();
              updateStats(); // Make sure this is called after data is processed

              renderHighlightedOptionsTable();
              renderPriceRangeTables(); // Apply current filters to price range tables
              renderRecoveryTable(); // Apply current filters to recovery table
              document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
          } else {
              console.warn("API response missing data property or is empty", data);
              document.getElementById('lastUpdated').textContent = new Date().toLocaleString() + " (Empty response)";
          }
      } catch (error) {
          console.error('Error fetching data:', error);
          document.getElementById('lastUpdated').textContent = new Date().toLocaleString() + " (Error)";
          // Don't show alert as it might be disruptive with auto-refresh
          console.error('Error loading data. Please try again.');
      }
  }

  // Function to render price range tables
  function renderPriceRangeTables() {
      // Apply active filters before filtering by price range
      let filteredData = filterDataByActiveFilters(allOrdersData);

      // Ensure index data is filtered out
      filteredData = filterOutIndexData(filteredData);

      // Filter data for +10% to +25% price change
      const lowMediumData = filteredData.filter(order =>
          order.percent_change > 10 && order.percent_change <= 25
      );

      // Filter data for +25% to +50% price change
      const mediumHighData = filteredData.filter(order =>
          order.percent_change > 25 && order.percent_change <= 50
      );

      // Filter data for +50% to +75% price change
      const highData = filteredData.filter(order =>
          order.percent_change > 50 && order.percent_change <= 75
      );

      // Filter data for +75% to +100% price change
      const veryHighData = filteredData.filter(order =>
          order.percent_change > 75 && order.percent_change <= 100
      );

      // Sort data by percent_change in descending order
      const sortedLowMediumData = [...lowMediumData].sort((a, b) => b.percent_change - a.percent_change);
      const sortedMediumHighData = [...mediumHighData].sort((a, b) => b.percent_change - a.percent_change);
      const sortedHighData = [...highData].sort((a, b) => b.percent_change - a.percent_change);
      const sortedVeryHighData = [...veryHighData].sort((a, b) => b.percent_change - a.percentChange);

      // Render tables with live bid/ask data
      renderPriceRangeTable(sortedLowMediumData, 'lowMediumTableBody');
      renderPriceRangeTable(sortedMediumHighData, 'mediumHighTableBody');
      renderPriceRangeTable(sortedHighData, 'highTableBody');
      renderPriceRangeTable(sortedVeryHighData, 'veryHighTableBody');
  }

 // Modified function to render price range table without index
  function renderPriceRangeTable(data, tableId) {
      const tableBody = document.getElementById(tableId);
      if (!tableBody) {
          console.error(`Table body with id ${tableId} not found`);
          return;
      }

      tableBody.innerHTML = '';

      if (data.length === 0) {
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = `<td colspan="11" class="text-center">No data available</td>`;
          tableBody.appendChild(emptyRow);
          return;
      }

      // Create a map of symbols from recovery table
      const recoverySymbols = new Set();

      // Get recovery data - options that dropped below thresholds but now have recovered
      const recoveryData = filterOutIndexData(allOrdersData).filter(order => {
          const hasDroppedBelow = order.is_less_than_25pct || order.is_less_than_50pct;
          const hasRecovered = order.current_ltp >= order.stored_ltp;
          return hasDroppedBelow && hasRecovered;
      });

      // Add all recovery symbols to the set
      recoveryData.forEach(order => {
          recoverySymbols.add(order.symbol);
      });

      data.forEach(order => {
          const row = document.createElement('tr');

          // Check if this option is highlighted
          const optionKey = `${order.symbol}-${order.strike_price}-${order.option_type}`;
          if (highlightedOptions[optionKey]) {
              row.classList.add(`highlight-${highlightedOptions[optionKey]}`);
          }

          // Format status with appropriate CSS class
          const statusClass = order.status === 'Done' ? 'status-done' : 'status-open';
          const statusDisplay = `<span class="${statusClass}">${order.status}</span>`;

          // Ensure values are safe
          const storedLtp = order.stored_ltp || 0;
          const currentLtp = order.current_ltp || 0;
          const percentChange = order.percent_change || 0;
          const lotSize = order.lot_size || 1;

          // Get live bid and ask quantities
          const liveBidQ = order.bidQ || 0;
          const liveAskQ = order.askQ || 0;

          // Check if bid or ask quantities exceed 50 * lot size
          const highBidQty = liveBidQ > (50 * lotSize);
          const highAskQty = liveAskQ > (50 * lotSize);

          // Format bid and ask with highlighting if needed
          const bidQtyClass = highBidQty ? 'high-quantity' : '';
          const askQtyClass = highAskQty ? 'high-quantity' : '';

          const bidQtyDisplay = formatLargeNumber(liveBidQ);
          const askQtyDisplay = formatLargeNumber(liveAskQ);

          // Check if this symbol is also in recovery table and add badge if needed
          let symbolDisplay = order.symbol;
          if (recoverySymbols.has(order.symbol)) {
              symbolDisplay = `<span class="recovery-overlap">${order.symbol} <span class="badge bg-success">Recovery</span></span>`;
          }

          // Determine milestone based on percentage change
          let milestoneText = 'New';
          let milestoneClass = 'milestone-new';
          if (order.is_greater_than_75pct) {
              milestoneText = '4th table';
              milestoneClass = 'milestone-75';
          } else if (order.is_greater_than_50pct) {
              milestoneText = '3rd table';
              milestoneClass = 'milestone-50';
          } else if (order.is_greater_than_25pct) {
              milestoneText = '2nd table';
              milestoneClass = 'milestone-25';
          }
          const milestone = `<span class="milestone-badge ${milestoneClass}">${milestoneText}</span>`;

          if (highBidQty || highAskQty) {
             row.classList.add('high-qty-row');
           }

          row.innerHTML = `
              <td>${symbolDisplay}</td>
              <td>${order.strike_price}</td>
              <td>${order.option_type}</td>
              <td>${order.role || 'Unknown'}</td>
              <td>${order.pcr.toFixed(2)}</td>
              <td>${storedLtp.toFixed(2)}</td>
              <td>${currentLtp.toFixed(2)}</td>
              <td class="profit">+${percentChange.toFixed(2)}%</td>
              <td>${milestone}</td>
              <td>${statusDisplay}</td>
              <td class="live-data ${bidQtyClass}">${bidQtyDisplay}</td>
              <td class="live-data ${askQtyClass}">${askQtyDisplay}</td>
              <td>${formatLargeNumber(order.oi || 0)}</td>
              <td>${formatLargeNumber(order.volume || 0)}</td>
          `;

          tableBody.appendChild(row);
      });

      // Apply highlighting to the table after rendering
      applyHighlightingToTable(tableBody);
  }

  function renderCurrentView() {
      let filteredData = filterDataByActiveFilters(allOrdersData);

      // Ensure index data is filtered out
      filteredData = filterOutIndexData(filteredData);

      // Apply view-specific filtering
      switch(currentView) {
          case 'higher':
              filteredData = filteredData.filter(order => order.percent_change > 0);
              break;
          case 'lower':
              filteredData = filteredData.filter(order => order.percent_change < 0);
              break;
          case 'moderate':
              filteredData = filteredData.filter(order =>
                  (order.percent_change >= -25 && order.percent_change <= 25)
              );
              break;
          case 'zero-to-ten':
              filteredData = filteredData.filter(order =>
                  (order.percent_change >= 0 && order.percent_change <= 10)
              );
              break;
          case 'low-medium':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 10 && order.percent_change <= 25)
              );
              break;
          case 'medium-high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 25 && order.percent_change <= 50)
              );
              break;
          case 'high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 50 && order.percent_change <= 75)
              );
              break;
          case 'very-high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 75 && order.percent_change <= 100)
              );
              break;
          case 'recovery':
              filteredData = filteredData.filter(order => {
                  // Check if recovery flags exist or determine them based on lowest point data
                  const hasBeenLow = order.is_less_than_25pct || order.is_less_than_50pct ||
                                    (order.lowest_point && order.lowest_point < order.stored_ltp * 0.5);

                  // Check if current price has recovered to equal or above original price
                  const hasRecovered = order.current_ltp >= order.stored_ltp;

                  return hasBeenLow && hasRecovered;
              });
              break;
      }

      // Apply sorting
      const sortedData = applySort(filteredData);

      // Render the table
      renderTable(sortedData, 'dataTableBody');


      // Also update the price range tables and recovery table
      renderPriceRangeTables();
      renderRecoveryTable();
  }

  function calculateDaysCaptured(timestamp) {
      if (!timestamp) return 'N/A';

      const captureDate = new Date(timestamp);
      const currentDate = new Date();
      const diffTime = Math.abs(currentDate - captureDate);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      return diffDays;
  }

  // Convert UTC timestamp to IST time format (DD, HH:MM)
  function formatISTTime(timestamp) {
      if (!timestamp) return 'N/A';

      // Create a date object from the timestamp
      const date = new Date(timestamp);

      // IST is UTC+5:30, so add 5 hours and 30 minutes to UTC time
      const istDate = new Date(date.getTime() + (5 * 60 + 30) * 60000);

      // Format time as DD, HH:MM
      const day = istDate.getUTCDate().toString().padStart(2, '0');
      const hours = istDate.getUTCHours().toString().padStart(2, '0');
      const minutes = istDate.getUTCMinutes().toString().padStart(2, '0');

      return `${day}, ${hours}:${minutes}`;
  }

  function calculateChange(currentValue, originalValue) {
      if (currentValue === null || originalValue === null) return null;
      if (originalValue === 0) return currentValue;

      return ((currentValue - originalValue) / Math.abs(originalValue)) * 100;
  }

  function renderTable(data, tableId) {
      const tableBody = document.getElementById(tableId);
      if (!tableBody) {
          console.error(`Table body with id ${tableId} not found`);
          return;
      }

      tableBody.innerHTML = '';

      console.log(`Rendering ${data.length} rows to ${tableId}`);  // Debug log

      if (data.length === 0) {
          // Add a row indicating no data
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = `<td colspan="29" class="text-center">No data available</td>`;
          tableBody.appendChild(emptyRow);
          return;
      }

      data.forEach((order, index) => {
          const row = document.createElement('tr');

          // Don't add any row index/number to the row

          // Add class based on performance

          // Check if this option is highlighted
          const optionKey = `${order.symbol}-${order.strike_price}-${order.option_type}`;
          if (highlightedOptions[optionKey]) {
              row.classList.add(`highlight-${highlightedOptions[optionKey]}`);
          }

          // Format greek changes with + or - sign and % symbol
          const formatGreekChange = (change) => {
              if (change === null || change === undefined) return 'N/A';
              const sign = change > 0 ? '+' : '';
              return `${sign}${change.toFixed(2)}%`;
          };

          // Handle null or undefined values safely
          const safeValue = (value, defaultValue = 0) => {
              return (value === null || value === undefined) ? defaultValue : value;
          };

          // Add check for null values
          const currentLtp = safeValue(order.current_ltp);
          const storedLtp = safeValue(order.stored_ltp);
          const percentChange = safeValue(order.percent_change);
          // Calculate Today's Return based on prev_close and current_ltp
          const prevClose = safeValue(order.prev_close);
          let todaysReturn = 0;
          if (prevClose > 0) {
              todaysReturn = ((currentLtp - prevClose) / prevClose) * 100;
          }

          // Store the calculated value in the order object for sorting
          order.todays_return = todaysReturn;

          // Format the status with appropriate CSS class
          const statusClass = order.status === 'Done' ? 'status-done' : 'status-open';
          const statusDisplay = `<span class="${statusClass}">${order.status}</span>`;

          // Format bid and ask quantities (convert to K or M for readability)
          const bidQ = formatLargeNumber(order.stored_bidq || 0);
          const askQ = formatLargeNumber(order.stored_askq || 0);

          // Get live bid and ask data
          const liveBid = safeValue(order.bid);
          const liveAsk = safeValue(order.ask);
          const liveBidQ = safeValue(order.bidQ);
          const liveAskQ = safeValue(order.askQ);

          // Format live bid and ask quantities
          const liveBidQDisplay = formatLargeNumber(liveBidQ);
          const liveAskQDisplay = formatLargeNumber(liveAskQ);

          // Check if bid or ask quantities exceed threshold
          const lotSize = order.lot_size || 1;
          const highBidQty = liveBidQ > ( (50 * lotSize) + liveAskQ );
          const highAskQty = liveAskQ > ( (50 * lotSize) + liveBidQ );

          // Format bid and ask with highlighting if needed
          const bidQtyClass = highBidQty ? 'high-quantity' : '';
          const askQtyClass = highAskQty ? 'high-quantity' : '';

          // Display symbol without any special highlighting
          const symbolDisplay = order.symbol;

          // Determine milestone based on percentage change
          let milestoneText = 'New';
          let milestoneClass = 'milestone-new';
          if (order.is_greater_than_75pct) {
              milestoneText = '4th table';
              milestoneClass = 'milestone-75';
          } else if (order.is_greater_than_50pct) {
              milestoneText = '3rd table';
              milestoneClass = 'milestone-50';
          } else if (order.is_greater_than_25pct) {
              milestoneText = '2nd table';
              milestoneClass = 'milestone-25';
          }
          const milestone = `<span class="milestone-badge ${milestoneClass}">${milestoneText}</span>`;

          if (highBidQty || highAskQty) {
              row.classList.add('high-qty-row');
          }

          row.innerHTML = `
              <td>${symbolDisplay}</td>
              <td>${order.strike_price}</td>
              <td>${order.option_type}</td>
              <td>${order.role || 'Unknown'}</td>
              <td>${order.daysCaptured || 'N/A'}</td>
              <td>${formatISTTime(order.timestamp)}</td>
              <td>${storedLtp.toFixed(2)}</td>
              <td>${currentLtp.toFixed(2)}</td>
              <td class="${percentChange > 0 ? 'profit' : 'loss'}">${percentChange.toFixed(2)}%</td>
              <td class="${todaysReturn > 0 ? 'profit' : 'loss'}">${todaysReturn.toFixed(2)}%</td>
              <td>${milestone}</td>
              <td>${statusDisplay}</td>
              <td class="${bidQtyClass}">${bidQ}</td>
              <td class="live-data">${liveBidQDisplay}</td>
              <td class="live-data">${liveAskQDisplay}</td>
              <td class="${askQtyClass}">${askQ}</td>
              <td>${formatLargeNumber(order.oi)}</td>
              <td class="${order.oi_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.oi_change)}</td>
              <td>${formatLargeNumber(order.volume)}</td>
              <td class="${order.volume_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.volume_change)}</td>
              <td>${order.iv ? order.iv.toFixed(2) + '%' : 'N/A'}</td>
              <td class="${order.iv_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.iv_change)}</td>
              <td>${order.delta ? order.delta.toFixed(2) : 'N/A'}</td>
              <td class="${order.delta_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.delta_change)}</td>
              <td>${order.gamma ? order.gamma.toFixed(4) : 'N/A'}</td>
              <td class="${order.gamma_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.gamma_change)}</td>
              <td>${order.theta ? order.theta.toFixed(2) : 'N/A'}</td>
              <td class="${order.theta_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.theta_change)}</td>
              <td>${order.vega ? order.vega.toFixed(2) : 'N/A'}</td>
              <td class="${order.vega_change > 0 ? 'profit' : 'loss'}">${formatGreekChange(order.vega_change)}</td>
              <td>${order.pop ? order.pop.toFixed(2) + '%' : 'N/A'}</td>
              <td>${order.pcr ? order.pcr.toFixed(2) : 'N/A'}</td>
          `;

          tableBody.appendChild(row);
      });

      // Apply highlighting to the table after rendering
      applyHighlightingToTable(tableBody);
  }

  function updateStats() {
      // Make sure we have data before calculating stats
      if (!allOrdersData || allOrdersData.length === 0) {
          console.warn("No data available for stats calculation");
          document.getElementById('totalOptions').textContent = '0';
          document.getElementById('profitableOptions').textContent = '0';
          document.getElementById('losingOptions').textContent = '0';
          document.getElementById('buyerSellerRatio').textContent = '0:0 / 0:0';
          return;
      }

      console.log(`Calculating stats for ${allOrdersData.length} options`);

      // Count options
      const totalOptions = allOrdersData.length;

      // Count profitable/losing options - ensure we filter out null values
      const profitableOptions = allOrdersData.filter(order => {
          return typeof order.percent_change === 'number' && order.percent_change > 0;
      }).length;

      const losingOptions = allOrdersData.filter(order => {
          return typeof order.percent_change === 'number' && order.percent_change < 0;
      }).length;

      // Count buyer/seller and open/done
      const buyerCount = allOrdersData.filter(order => order.role === 'Buyer').length;
      const sellerCount = allOrdersData.filter(order => order.role === 'Seller').length;
      const openCount = allOrdersData.filter(order => order.status === 'Open').length;
      const doneCount = allOrdersData.filter(order => order.status === 'Done').length;

      // Debug log to verify counts
      console.log(`Stats: Total=${totalOptions}, Profit=${profitableOptions}, Loss=${losingOptions}`);
      console.log(`Buyers=${buyerCount}, Sellers=${sellerCount}, Open=${openCount}, Done=${doneCount}`);

      // Update UI
      document.getElementById('totalOptions').textContent = totalOptions;
      document.getElementById('profitableOptions').textContent = profitableOptions;
      document.getElementById('losingOptions').textContent = losingOptions;
      document.getElementById('buyerSellerRatio').textContent = `${buyerCount}:${sellerCount} / ${openCount}:${doneCount}`;
  }

  function filterTable(filter) {
      // For backward compatibility, set this filter as the only active filter
      activeFilters = [filter];
      if (filter === 'all') {
          activeFilters = [];
      }

      // Update UI to reflect the single active filter
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      if (filter === 'all') {
          document.querySelector('.filter-btn[data-filter="all"]').classList.add('active');
      } else {
          document.querySelector(`.filter-btn[data-filter="${filter}"]`).classList.add('active');
      }

      let filteredData = filterDataByActiveFilters(allOrdersData);

      // Also update the higher/lower/moderate price tables with the filtered data
      let higherPriceData = filteredData.filter(order => order.percent_change > 0);
      let lowerPriceData = filteredData.filter(order => order.percent_change < 0);
      let moderateChangeData = filteredData.filter(order =>
          (order.percent_change >= -25 && order.percent_change < 0) ||
          (order.percent_change > 0 && order.percent_change <= 25)
      );

      renderTable(applySort(filteredData), 'allOrdersTableBody');
      renderTable(applySort(higherPriceData), 'higherPriceTableBody');
      renderTable(applySort(lowerPriceData), 'lowerPriceTableBody');
      renderTable(applySort(moderateChangeData), 'moderateChangeTableBody');
  }

  // Helper function to filter data based on active filters
  function filterDataByActiveFilters(data) {
      // Ensure index data is filtered out first
      data = filterOutIndexData(data);

      // Apply date filtering
      data = data.filter(order => isWithinDateFilter(order));

      // If no filters or only 'all' filter is active, return date-filtered data
      if (activeFilters.length === 0) {
        return data;
      }

      return data.filter(order => {
          // Group filters by category
          const profitLossFilters = activeFilters.filter(f => f === 'profit' || f === 'loss');
          const roleFilters = activeFilters.filter(f => f === 'buyer' || f === 'seller');
          const statusFilters = activeFilters.filter(f => f === 'open' || f === 'done');
          const newFilters = activeFilters.filter(f => f === 'new');

          // Default all categories to true if no filters in that category
          let matchesProfitLoss = profitLossFilters.length === 0;
          let matchesRole = roleFilters.length === 0;
          let matchesStatus = statusFilters.length === 0;
          let matchesNew = newFilters.length === 0;

          // Check profit/loss category
          if (profitLossFilters.length > 0) {
              matchesProfitLoss = profitLossFilters.some(filter => {
                  if (filter === 'profit') return order.percent_change > 0;
                  if (filter === 'loss') return order.percent_change < 0;
                  return false;
              });
          }

          // Check role category
          if (roleFilters.length > 0) {
              matchesRole = roleFilters.some(filter => {
                  if (filter === 'buyer') return order.role === 'Buyer';
                  if (filter === 'seller') return order.role === 'Seller';
                  return false;
              });
          }

          // Check status category
          if (statusFilters.length > 0) {
              matchesStatus = statusFilters.some(filter => {
                  if (filter === 'open') return order.status === 'Open';
                  if (filter === 'done') return order.status === 'Done';
                  return false;
              });
          }

          // Check new/unassigned category
          if (newFilters.length > 0) {
              matchesNew = newFilters.some(filter => {
                  if (filter === 'new') {
                      // Check if not assigned to any percentage table (not in any milestone)
                      return !order.is_greater_than_25pct &&
                             !order.is_greater_than_50pct &&
                             !order.is_greater_than_75pct;
                  }
                  return false;
              });
          }

          // All categories must match (AND between categories)
          return matchesProfitLoss && matchesRole && matchesStatus && matchesNew;
      });
  }

  // Helper function to apply current sort to data
  // Helper function to apply current sort to data
function applySort(data) {
    if (!currentSort.column) return data;

    return [...data].sort((a, b) => {
        let aValue, bValue;

        if (currentSort.column === 'milestone') {
            // Custom logic for milestone sorting - pass the entire order object
            aValue = getMilestoneValue(a.percent_change, a);
            bValue = getMilestoneValue(b.percent_change, b);
        } else {
            aValue = a[currentSort.column] === null ? 0 : a[currentSort.column];
            bValue = b[currentSort.column] === null ? 0 : b[currentSort.column];
        }

        if (currentSort.column === 'symbol') {
            aValue = String(aValue);
            bValue = String(bValue);
            return currentSort.direction === 'asc'
                ? aValue.localeCompare(bValue)
                : bValue.localeCompare(aValue);
        }

        return currentSort.direction === 'asc'
            ? aValue - bValue
            : bValue - aValue;
    });
}

  // Helper function to convert percent change to milestone numeric value for sorting
  function getMilestoneValue(percentChange) {
      if (percentChange > 75) return 4;
      if (percentChange > 50) return 3;
      if (percentChange > 25) return 2;
      if (percentChange > 0) return 1;
      return 0;
  }


  function formatLargeNumber(num) {
      if (!num) return '0';

      if (num >= 1000000) {
          return (num / 1000000).toFixed(2) + 'M';
      } else if (num >= 1000) {
          return (num / 1000).toFixed(2) + 'K';
      }
      return num.toString();
  }

  function applyFilters() {
      let filteredData = filterDataByActiveFilters(allOrdersData);

      // Apply current view filtering
      switch(currentView) {
          case 'higher':
              filteredData = filteredData.filter(order => order.percent_change > 0);
              break;
          case 'lower':
              filteredData = filteredData.filter(order => order.percent_change < 0);
              break;
          case 'moderate':
              filteredData = filteredData.filter(order =>
                  (order.percent_change >= -25 && order.percent_change <= 25)
              );
              break;
          case 'zero-to-ten':
              filteredData = filteredData.filter(order =>
                  (order.percent_change >= 0 && order.percent_change <= 10)
              );
              break;
          case 'low-medium':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 10 && order.percent_change <= 25)
              );
              break;
          case 'medium-high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 25 && order.percent_change <= 50)
              );
              break;
          case 'high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 50 && order.percent_change <= 75)
              );
              break;
          case 'very-high':
              filteredData = filteredData.filter(order =>
                  (order.percent_change > 75 && order.percent_change <= 100)
              );
              break;
      }

      // Apply sorting
      const sortedData = applySort(filteredData);

      // Render the table
      renderTable(sortedData, 'dataTableBody');


      // Add this line to update the highlighted options table
      renderHighlightedOptionsTable();

      // Existing code for price range tables and recovery table
      renderPriceRangeTables();
      renderRecoveryTable();
}

  function renderRecoveryTable() {
      const recoveryTableBody = document.getElementById('recoveryTableBody');
      if (!recoveryTableBody) {
          console.error('Recovery table body not found');
          return;
      }

      recoveryTableBody.innerHTML = '';

      // Filter data for options that previously dropped below thresholds but now have recovered
      // First ensure index data is filtered out
      let filteredData = filterOutIndexData(allOrdersData);

      const recoveryData = filteredData.filter(order => {
          // Check if the option has ever been flagged as dropping below thresholds
          const hasDroppedBelow = order.is_less_than_25pct || order.is_less_than_50pct;

          // Check if the current price has recovered to at least the original price
          // Make sure we're using the latest live price data
          const hasRecovered = order.current_ltp >= order.stored_ltp;

          // Both conditions must be true for this to be a recovery case
          return hasDroppedBelow && hasRecovered;
      });

      console.log(`Found ${recoveryData.length} options with price recovery`);

      if (recoveryData.length === 0) {
          // Add a row indicating no data
          const emptyRow = document.createElement('tr');
          emptyRow.innerHTML = `<td colspan="15" class="text-center">No options with price recovery found</td>`;
          recoveryTableBody.appendChild(emptyRow);
          return;
      }

      // Sort by the highest percentage recovery (from lowest point to current)
      recoveryData.sort((a, b) => {
          // Calculate recovery percentage from lowest point for each order
          const aLowestPoint = getLowestPoint(a);
          const bLowestPoint = getLowestPoint(b);

          const aRecoveryFromLowest = aLowestPoint > 0 ? (a.current_ltp / aLowestPoint) : 0;
          const bRecoveryFromLowest = bLowestPoint > 0 ? (b.current_ltp / bLowestPoint) : 0;

          return bRecoveryFromLowest - aRecoveryFromLowest;
      });

      // Helper function to determine lowest point consistently
      function getLowestPoint(order) {
          if (order.lowest_point && order.lowest_point > 0) {
              return order.lowest_point;
          } else if (order.is_less_than_25pct) {
              return order.stored_ltp * 0.25;
          } else if (order.is_less_than_50pct) {
              return order.stored_ltp * 0.5;
          } else {
              // Fallback - shouldn't happen in recovery data
              return Math.min(order.current_ltp, order.stored_ltp);
          }
      }

      // Create a map of symbols from percentage tables
      const percentageTableSymbols = new Map();

      // Check if a stock is in 10-25% range
      const lowMediumData = filterOutIndexData(allOrdersData).filter(order =>
          order.percent_change > 10 && order.percent_change <= 25
      );
      lowMediumData.forEach(order => {
          percentageTableSymbols.set(order.symbol, "10-25%");
      });

      // Check if a stock is in 25-50% range
      const mediumHighData = filterOutIndexData(allOrdersData).filter(order =>
          order.percent_change > 25 && order.percent_change <= 50
      );
      mediumHighData.forEach(order => {
          percentageTableSymbols.set(order.symbol, "25-50%");
      });

      // Check if a stock is in 50-75% range
      const highData = filterOutIndexData(allOrdersData).filter(order =>
          order.percent_change > 50 && order.percent_change <= 75
      );
      highData.forEach(order => {
          percentageTableSymbols.set(order.symbol, "50-75%");
      });

      // Check if a stock is in 75-100% range
      const veryHighData = filterOutIndexData(allOrdersData).filter(order =>
          order.percent_change > 75 && order.percent_change <= 100
      );
      veryHighData.forEach(order => {
          percentageTableSymbols.set(order.symbol, "75-100%");
      });

      recoveryData.forEach(order => {
          const row = document.createElement('tr');

          // Check if this option is highlighted
          const optionKey = `${order.symbol}-${order.strike_price}-${order.option_type}`;
          if (highlightedOptions[optionKey]) {
              row.classList.add(`highlight-${highlightedOptions[optionKey]}`);
          }

          // Calculate days since capture
          const daysCaptured = order.daysCaptured || 'N/A';

          // Find lowest point using our helper function
          const lowestPoint = getLowestPoint(order);

          // Get the live price from market data if available
          const liveLtp = order.ltp || order.current_ltp || 0;

          // Use live LTP for calculations if available
          const currentLtp = liveLtp;

          // Calculate recovery percentage from original price
          const recoveryFromOriginal = ((currentLtp / order.stored_ltp) * 100) - 100;

          // Calculate recovery percentage from lowest point (more impressive number)
          const recoveryFromLowest = lowestPoint > 0 ?
              ((currentLtp / lowestPoint) * 100) - 100 : 0;

          // Format status with appropriate CSS class
          const statusClass = order.status === 'Done' ? 'status-done' : 'status-open';
          const statusDisplay = `<span class="${statusClass}">${order.status}</span>`;

          // Ensure safe values
          const storedLtp = order.stored_ltp || 0;

          // Get live bid and ask quantities for display in recovery table
          const liveBidQ = order.bidQ || 0;
          const liveAskQ = order.askQ || 0;

          // Check if bid or ask quantities exceed threshold (same as in price range tables)
          const lotSize = order.lot_size || 1;
          const highBidQty = liveBidQ > (50 * lotSize);
          const highAskQty = liveAskQ > (50 * lotSize);

          // Format bid and ask with highlighting if needed
          const bidQtyClass = highBidQty ? 'high-quantity' : '';
          const askQtyClass = highAskQty ? 'high-quantity' : '';

          const bidQtyDisplay = formatLargeNumber(liveBidQ);
          const askQtyDisplay = formatLargeNumber(liveAskQ);

          // Check if this symbol is also in a percentage table
          let symbolDisplay = order.symbol;
          if (percentageTableSymbols.has(order.symbol)) {
              const rangeLabel = percentageTableSymbols.get(order.symbol);
              symbolDisplay = `<span class="recovery-overlap">${order.symbol} <span class="badge bg-info">Also in ${rangeLabel}</span></span>`;
          }

          // Determine the lowest milestone hit
          let lowestMilestone = "";
          if (order.is_less_than_25pct === true) {
              lowestMilestone = "<span class='badge bg-danger'>Below 25%</span>";
          } else if (order.is_less_than_50pct === true) {
              lowestMilestone = "<span class='badge bg-warning text-dark'>Below 50%</span>";
          } else {
              lowestMilestone = "<span class='badge bg-secondary'>Safe</span>";
          }

          row.innerHTML = `
              <td>${symbolDisplay}</td>
              <td>${order.strike_price}</td>
              <td>${order.option_type}</td>
              <td>${order.role || 'Unknown'}</td>
              <td>${daysCaptured}</td>
              <td>${storedLtp.toFixed(2)}</td>
              <td class="live-data">${liveLtp.toFixed(2)}</td>
              <td class="profit">+${recoveryFromOriginal.toFixed(2)}% (↑${recoveryFromLowest.toFixed(2)}% from low)</td>
              <td>${lowestMilestone}</td>
              <td>${statusDisplay}</td>
              <td class="live-data ${bidQtyClass}">${bidQtyDisplay}</td>
              <td class="live-data ${askQtyClass}">${askQtyDisplay}</td>
              <td>${formatLargeNumber(order.oi || 0)}</td>
              <td>${formatLargeNumber(order.volume || 0)}</td>
          `;

          recoveryTableBody.appendChild(row);
      });

      // Apply highlighting to the table after rendering
      applyHighlightingToTable(recoveryTableBody);
  }

// Date Filtering Functions

// Function to create and show a custom date range modal
function createCustomDateRangeModal() {
  // Create modal backdrop
  const modalBackdrop = document.createElement('div');
  modalBackdrop.className = 'modal-backdrop fade show';
  document.body.appendChild(modalBackdrop);

  // Create modal HTML
  const modalHtml = `
    <div class="modal fade show" id="customDateRangeModal" tabindex="-1" style="display: block;" aria-modal="true" role="dialog">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Select Custom Date Range</h5>
            <button type="button" class="btn-close" id="closeCustomDateModal"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="startDate" class="form-label">Start Date</label>
              <input type="date" class="form-control" id="startDate" required>
            </div>
            <div class="mb-3">
              <label for="endDate" class="form-label">End Date</label>
              <input type="date" class="form-control" id="endDate" required>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="cancelCustomDateRange">Cancel</button>
            <button type="button" class="btn btn-primary" id="applyCustomDateRange">Apply</button>
          </div>
        </div>
      </div>
    </div>
  `;

  // Add modal to body
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHtml;
  document.body.appendChild(modalContainer);

  // Set current dates if any
  if (customDateRange.start) {
    document.getElementById('startDate').value = customDateRange.start;
  } else {
    // Set default start date to 7 days ago
    const defaultStart = new Date();
    defaultStart.setDate(defaultStart.getDate() - 7);
    document.getElementById('startDate').value = formatDateForInput(defaultStart);
  }

  if (customDateRange.end) {
    document.getElementById('endDate').value = customDateRange.end;
  } else {
    // Set default end date to today
    document.getElementById('endDate').value = formatDateForInput(new Date());
  }

  // Helper function to format date for input field
  function formatDateForInput(date) {
    return date.toISOString().split('T')[0];
  }

  // Handle cancel/close
  function closeModal() {
    document.body.removeChild(modalBackdrop);
    document.body.removeChild(modalContainer);
  }

  document.getElementById('closeCustomDateModal').addEventListener('click', closeModal);
  document.getElementById('cancelCustomDateRange').addEventListener('click', closeModal);

  // Handle apply
  document.getElementById('applyCustomDateRange').addEventListener('click', function() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;

    if (startDate && endDate) {
      // Clear active state from all date filter buttons
      document.querySelectorAll('.date-filter-btn').forEach(btn => btn.classList.remove('active'));

      // Set custom date range
      customDateRange.start = startDate;
      customDateRange.end = endDate;

      // Reset the days filter since we're using custom range
      activeDateFilter = -1;

      // Apply filters with new custom date range
      applyFilters();

      // Close modal
      closeModal();
    }
  });
}

// Function to check if an order is within the active date filter
function isWithinDateFilter(order) {
  if (!order.timestamp) return true;

  const orderDate = new Date(order.timestamp);
  const currentDate = new Date();

  // Handle custom date range
  if (customDateRange.start && customDateRange.end) {
    const startDate = new Date(customDateRange.start);
    const endDate = new Date(customDateRange.end);
    // Set end date to end of day
    endDate.setHours(23, 59, 59, 999);

    return orderDate >= startDate && orderDate <= endDate;
  }

  // Handle day-based filters
  if (activeDateFilter > 0) {
    const filterDate = new Date();
    filterDate.setDate(currentDate.getDate() - activeDateFilter);
    filterDate.setHours(0, 0, 0, 0);

    return orderDate >= filterDate;
  }

  // Default case: no date filter (all time)
  return true;
}

// Modified function to filter data based on active filters with date filtering
function filterDataByActiveFilters(data) {
  // Ensure index data is filtered out first
  data = filterOutIndexData(data);

  // Apply date filtering
  data = data.filter(order => isWithinDateFilter(order));

  // If no filters or only 'all' filter is active, return date-filtered data
  if (activeFilters.length === 0) {
    return data;
  }

  return data.filter(order => {
    // Group filters by category
    const profitLossFilters = activeFilters.filter(f => f === 'profit' || f === 'loss');
    const roleFilters = activeFilters.filter(f => f === 'buyer' || f === 'seller');
    const statusFilters = activeFilters.filter(f => f === 'open' || f === 'done');
    const newFilters = activeFilters.filter(f => f === 'new');

    // Default all categories to true if no filters in that category
    let matchesProfitLoss = profitLossFilters.length === 0;
    let matchesRole = roleFilters.length === 0;
    let matchesStatus = statusFilters.length === 0;
    let matchesNew = newFilters.length === 0;

    // Check profit/loss category
    if (profitLossFilters.length > 0) {
      matchesProfitLoss = profitLossFilters.some(filter => {
        if (filter === 'profit') return order.percent_change > 0;
        if (filter === 'loss') return order.percent_change < 0;
        return false;
      });
    }

    // Check role category
    if (roleFilters.length > 0) {
      matchesRole = roleFilters.some(filter => {
        if (filter === 'buyer') return order.role === 'Buyer';
        if (filter === 'seller') return order.role === 'Seller';
        return false;
      });
    }

    // Check status category
    if (statusFilters.length > 0) {
      matchesStatus = statusFilters.some(filter => {
        if (filter === 'open') return order.status === 'Open';
        if (filter === 'done') return order.status === 'Done';
        return false;
      });
    }

    // Check new/unassigned category
    if (newFilters.length > 0) {
      matchesNew = newFilters.some(filter => {
        if (filter === 'new') {
          // Check if not assigned to any percentage table (not in any milestone)
          return !order.is_greater_than_25pct &&
                !order.is_greater_than_50pct &&
                !order.is_greater_than_75pct;
        }
        return false;
      });
    }

    // All categories must match (AND between categories)
    return matchesProfitLoss && matchesRole && matchesStatus && matchesNew;
  });
}

// Set up date filter buttons event listeners
function setupDateFilterButtons() {
  // Set up date filter buttons
  document.querySelectorAll('.date-filter-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      // Remove active class from all date filter buttons
      document.querySelectorAll('.date-filter-btn').forEach(b => b.classList.remove('active'));

      // Add active class to clicked button
      this.classList.add('active');

      // Update active date filter
      activeDateFilter = parseInt(this.dataset.days);

      // Reset custom date range when using preset filters
      customDateRange = { start: null, end: null };

      // Apply filters with new date filter
      applyFilters();
    });
  });

  // Set up custom date range button
  document.getElementById('customDateRangeBtn').addEventListener('click', function() {
    createCustomDateRangeModal();
  });

  // Set the default "All Time" date filter as active
  const defaultDateFilter = document.querySelector('.date-filter-btn[data-default="true"]');
  if (defaultDateFilter) {
    defaultDateFilter.classList.add('active');
  }
}

// Initialize the date filters when the document is loaded
document.addEventListener('DOMContentLoaded', function() {
  // Call setup function
  setupDateFilterButtons();
});

</script>

</body>
</html>
