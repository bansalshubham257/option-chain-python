<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Strategy Performance Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    /* Critical full-width overrides */
    html, body {
        width: 100% !important;
        max-width: 100% !important;
        overflow-x: hidden !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    /* Override any Bootstrap constraints */
    .container-fluid {
        width: 100% !important;
        max-width: 100% !important;
        padding-left: 15px !important;
        padding-right: 15px !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
    }

    /* Force table to use full width */
    .table-responsive {
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    /* Colors for P&L */
    .profit {
        color: green;
        font-weight: bold;
    }
    .loss {
        color: red;
        font-weight: bold;
    }

    /* Order status styles */
    .status-open {
        color: blue;
        font-weight: bold;
    }
    .status-profit {
        color: green;
        font-weight: bold;
    }
    .status-loss {
        color: red;
        font-weight: bold;
    }
    .status-expired {
        color: purple;
        font-weight: bold;
    }

    /* Highlight for active trades */
    .active-trade {
        background-color: rgba(255, 255, 0, 0.2);
    }

    /* Metric card styles */
    .metric-card {
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 15px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    .metric-value {
        font-size: 1.8rem;
        font-weight: bold;
    }

    .metric-label {
        font-size: 0.9rem;
        color: #6c757d;
    }

    .total-capital {
        background-color: #f8f9fa;
        border-left: 4px solid #0d6efd;
    }

    .profit-card {
        background-color: #f0fff4;
        border-left: 4px solid #28a745;
    }

    .loss-card {
        background-color: #fff5f5;
        border-left: 4px solid #dc3545;
    }

    .orders-card {
        background-color: #f0f4ff;
        border-left: 4px solid #6610f2;
    }

    /* Historical performance chart */
    .chart-container {
        height: 300px;
        margin-bottom: 20px;
    }

    /* Monthly performance table */
    .monthly-performance th {
        position: sticky;
        top: 0;
        background-color: #f8f9fa;
    }

    /* Sortable table styles */
    .sortable {
        cursor: pointer;
    }

    .sortable:hover {
        background-color: #f1f1f1;
    }

    .sortable::after {
        content: "⇅";
        margin-left: 5px;
        opacity: 0.5;
    }

    .sortable.asc::after {
        content: "↑";
        opacity: 1;
    }

    .sortable.desc::after {
        content: "↓";
        opacity: 1;
    }

    /* Pagination styles */
    .pagination-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 15px;
    }

    .page-info {
      color: #6c757d;
    }

    .pagination {
      margin-bottom: 0;
    }
  </style>
</head>
<body>
<div class="container-fluid">
  <h1 class="text-center mb-3">Strategy Performance Dashboard</h1>

  <!-- Controls Row -->
  <div class="row mb-3">
    <div class="col-md-4">
      <div class="d-flex align-items-center">
        <button id="refreshBtn" class="btn btn-primary me-2">Refresh Data</button>
        <span class="text-muted">Last updated: <span id="lastUpdated">Never</span></span>
      </div>
    </div>
    <div class="col-md-4 text-center">
      <div class="form-group">
        <label for="strategySelector" class="me-2">Strategy:</label>
        <select id="strategySelector" class="form-select form-select-sm d-inline-block" style="width: auto;">
          <option value="all">All Strategies</option>
          <option value="percent_change_tracker">Conservative (5% Entry, 15% SL)</option>
          <option value="aggressive_tracker">Aggressive (10% Entry, 30% SL)</option>
          <option value="high_risk_tracker">High Risk (8% Entry, 60% SL)</option>
        </select>
      </div>
    </div>
    <div class="col-md-4 text-end">
      <div class="btn-group" role="group">
        <button type="button" class="btn btn-outline-primary filter-btn active" data-filter="all">All Orders</button>
        <button type="button" class="btn btn-outline-success filter-btn" data-filter="profit">Profit</button>
        <button type="button" class="btn btn-outline-danger filter-btn" data-filter="loss">Loss</button>
        <button type="button" class="btn btn-outline-primary filter-btn" data-filter="open">Open</button>
        <button type="button" class="btn btn-outline-secondary filter-btn" data-filter="expired">Expired</button>
      </div>
    </div>
  </div>

  <!-- Key Metrics Cards -->
  <div class="row mb-4">
    <div class="col-md-3">
      <div class="metric-card total-capital">
        <div class="metric-value" id="totalCapital">₹0</div>
        <div class="metric-label">Total Capital Deployed</div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="metric-card profit-card">
        <div class="metric-value profit" id="totalProfit">₹0</div>
        <div class="metric-label">Total Profit</div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="metric-card loss-card">
        <div class="metric-value loss" id="totalLoss">₹0</div>
        <div class="metric-label">Total Loss</div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="metric-card orders-card">
        <div class="metric-value" id="orderStats">0 / 0</div>
        <div class="metric-label">Orders (Open / Total)</div>
      </div>
    </div>
  </div>

  <!-- Strategy Comparison Section -->
  <div class="row mb-4" id="strategyComparisonSection">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-primary text-white">
          <h4>Strategy Comparison</h4>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead>
                <tr>
                  <th>Strategy</th>
                  <th>Total Orders</th>
                  <th>Win Rate</th>
                  <th>Avg Profit %</th>
                  <th>Avg Loss %</th>
                  <th>Total P&L</th>
                  <th>Max Capital</th>
                  <th>ROI</th>
                </tr>
              </thead>
              <tbody id="strategyComparisonTableBody">
                <!-- Strategy comparison will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Strategy Summary Table (New) -->
  <div class="row mb-4" id="strategySummarySection">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-primary text-white">
          <h4>Strategy Summary</h4>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead>
                <tr>
                  <th>Strategy</th>
                  <th>Open Orders</th>
                  <th>Closed Orders</th>
                  <th>Total Profit</th>
                  <th>Total Loss</th>
                  <th>Net P&L</th>
                  <th>Current Capital</th>
                </tr>
              </thead>
              <tbody id="strategySummaryTableBody">
                <!-- Strategy summary will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Performance Chart -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-primary text-white">
          <h4>Performance Over Time</h4>
        </div>
        <div class="card-body">
          <div class="chart-container">
            <canvas id="performanceChart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Live Open Orders -->
  <div class="row mb-4" id="activeOrdersSection">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-primary text-white">
          <h4>Active Orders</h4>
          <div class="d-flex justify-content-between align-items-center">
            <p class="mb-0">Currently open positions with live P&L tracking</p>
            <div>Total P&L: <span id="totalActivePnl" class="fw-bold badge" style="font-size: 1rem;">₹0.00</span></div>
          </div>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-hover">
              <thead>
                <tr>
                  <th class="sortable" data-sort="symbol">Symbol</th>
                  <th>Strike</th>
                  <th>Type</th>
                  <th>Entry Price</th>
                  <th>Current Price</th>
                  <th>Target</th>
                  <th>Stop Loss</th>
                  <th>Qty</th>
                  <th class="sortable" data-sort="entry_time">Entry Time</th>
                  <th class="sortable" data-sort="days">Days Open</th>
                  <th class="sortable" data-sort="pnl">Unrealized P&L</th>
                  <th class="sortable" data-sort="pnl-percent">P&L %</th>
                </tr>
              </thead>
              <tbody id="activeOrdersTableBody">
                <!-- Active orders will be dynamically added here -->
              </tbody>
            </table>
            <div class="pagination-container" id="activeOrdersPagination">
              <div class="page-info">
                Showing <span id="activeOrdersStart">0</span> to <span id="activeOrdersEnd">0</span> of <span id="activeOrdersTotal">0</span> entries
              </div>
              <ul class="pagination" id="activeOrdersPageButtons">
                <!-- Pagination buttons will be dynamically added here -->
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Closed Orders -->
  <div class="row mb-4" id="closedOrdersSection">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-success text-white">
          <h4>Closed Orders</h4>
          <p class="mb-0">Historical orders with performance metrics</p>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-hover">
              <thead>
                <tr>
                  <th class="sortable" data-sort="symbol">Symbol</th>
                  <th>Strike</th>
                  <th>Type</th>
                  <th>Entry Price</th>
                  <th>Exit Price</th>
                  <th>Qty</th>
                  <th class="sortable" data-sort="entry_time">Entry Time</th>
                  <th class="sortable" data-sort="exit_time">Exit Time</th>
                  <th class="sortable" data-sort="status">Status</th>
                  <th class="sortable" data-sort="pnl">P&L</th>
                  <th class="sortable" data-sort="pnl-percent">P&L %</th>
                </tr>
              </thead>
              <tbody id="closedOrdersTableBody">
                <!-- Closed orders will be dynamically added here -->
              </tbody>
            </table>
            <div class="pagination-container" id="closedOrdersPagination">
              <div class="page-info">
                Showing <span id="closedOrdersStart">0</span> to <span id="closedOrdersEnd">0</span> of <span id="closedOrdersTotal">0</span> entries
              </div>
              <ul class="pagination" id="closedOrdersPageButtons">
                <!-- Pagination buttons will be dynamically added here -->
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Monthly Performance -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header bg-info text-white">
          <h4>Monthly Performance</h4>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-striped table-hover monthly-performance">
              <thead>
                <tr>
                  <th>Month</th>
                  <th>Total Orders</th>
                  <th>Profit Orders</th>
                  <th>Loss Orders</th>
                  <th>Win Rate</th>
                  <th>Total P&L</th>
                  <th>Avg Profit %</th>
                  <th>Avg Loss %</th>
                  <th>Max Capital</th>
                </tr>
              </thead>
              <tbody id="monthlyPerformanceTableBody">
                <!-- Monthly performance will be dynamically added here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  // Global variables
  let activeOrders = [];
  let closedOrders = [];
  let monthlyPerformance = [];
  let performanceChart = null;
  let currentFilter = 'all';
  let currentSort = { table: null, column: null, direction: null };

  // Pagination settings
  const paginationSettings = {
    itemsPerPage: 30,
    activeOrders: {
      currentPage: 1
    },
    closedOrders: {
      currentPage: 1
    }
  };

  // API endpoint - configure this to match your backend
  const apiBaseUrl = 'https://order-creation-ui-api-production.up.railway.app';

  // Initialize the page
  document.addEventListener('DOMContentLoaded', function() {
    // Set up refresh button
    document.getElementById('refreshBtn').addEventListener('click', fetchData);

    // Set up filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const filter = this.dataset.filter;
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        currentFilter = filter;
        applyFilters();
      });
    });

    // Set up strategy selector
    document.getElementById('strategySelector').addEventListener('change', function() {
      const selectedStrategy = this.value;
      fetchData(); // Refetch data with the new strategy

      // Toggle sections visibility based on selected strategy
      updateSectionsVisibility(selectedStrategy);
    });

    // Set up sortable columns
    document.querySelectorAll('th.sortable').forEach(th => {
      th.addEventListener('click', function() {
        const sortType = this.dataset.sort;
        const tableId = this.closest('table').querySelector('tbody').id;
        const direction = this.classList.contains('asc') ? 'desc' : 'asc';

        // Reset all sorting indicators in this table
        this.closest('table').querySelectorAll('th.sortable').forEach(header => {
          header.classList.remove('asc', 'desc');
        });

        // Set this column's sort direction
        this.classList.add(direction);

        // Update current sort
        currentSort = {
          table: tableId,
          column: sortType,
          direction: direction
        };

        // Reset to first page when sorting changes
        if (tableId === 'activeOrdersTableBody') {
          paginationSettings.activeOrders.currentPage = 1;
          renderActiveOrders(activeOrders);
        } else if (tableId === 'closedOrdersTableBody') {
          paginationSettings.closedOrders.currentPage = 1;
          renderClosedOrders(closedOrders);
        }
      });
    });

    // Initial data load
    fetchData();

    // Set initial sections visibility
    updateSectionsVisibility(document.getElementById('strategySelector').value);

    // Set up auto-refresh every 30 seconds
    setInterval(fetchData, 30000);
  });

  // Function to update sections visibility based on selected strategy
  function updateSectionsVisibility(selectedStrategy) {
    const activeOrdersSection = document.getElementById('activeOrdersSection');
    const closedOrdersSection = document.getElementById('closedOrdersSection');
    const strategySummarySection = document.getElementById('strategySummarySection');
    const comparisonSection = document.getElementById('strategyComparisonSection');

    if (selectedStrategy === 'all') {
      // When "All Strategies" is selected, hide individual orders and show summary/comparison
      activeOrdersSection.style.display = 'none';
      closedOrdersSection.style.display = 'none';
      strategySummarySection.style.display = 'block';
      comparisonSection.style.display = 'block';
    } else {
      // When a specific strategy is selected, show orders and hide comparison
      activeOrdersSection.style.display = 'flex';
      closedOrdersSection.style.display = 'flex';
      strategySummarySection.style.display = 'none';
      comparisonSection.style.display = 'none';
    }
  }

  async function fetchData() {
    try {
      // Get the currently selected strategy
      const selectedStrategy = document.getElementById('strategySelector').value;
      const strategyParam = selectedStrategy !== 'all' ? `?strategy=${selectedStrategy}` : '';

      // Fetch active orders
      const activeOrdersResponse = await fetch(`${apiBaseUrl}/api/strategy/active-orders${strategyParam}`);
      const activeOrdersData = await activeOrdersResponse.json();
      activeOrders = activeOrdersData.orders || [];

      // Log data for debugging
      console.log(`Active orders for ${selectedStrategy}:`, activeOrders.length);

      // Fetch closed orders
      const closedOrdersResponse = await fetch(`${apiBaseUrl}/api/strategy/closed-orders${strategyParam}`);
      const closedOrdersData = await closedOrdersResponse.json();
      closedOrders = closedOrdersData.orders || [];

      console.log(`Closed orders for ${selectedStrategy}:`, closedOrders.length);

      // Fetch monthly performance
      const monthlyResponse = await fetch(`${apiBaseUrl}/api/strategy/monthly-performance${strategyParam}`);
      const monthlyData = await monthlyResponse.json();
      monthlyPerformance = monthlyData.performance || [];

      // Fetch summary metrics (with strategy filter if not "all")
      const summaryUrl = selectedStrategy !== 'all'
        ? `${apiBaseUrl}/api/strategy/summary?strategy=${selectedStrategy}`
        : `${apiBaseUrl}/api/strategy/summary`;
      const summaryResponse = await fetch(summaryUrl);
      const summaryData = await summaryResponse.json();

      // Always fetch comparison data (showing all strategies)
      const comparisonResponse = await fetch(`${apiBaseUrl}/api/strategy/comparison`);
      const comparisonData = await comparisonResponse.json();

      // Update the UI based on the selected strategy
      updateMetrics(summaryData);

      if (selectedStrategy === 'all') {
        // For "All Strategies", update the summary and comparison tables
        renderStrategyComparisonFromAPI(comparisonData.comparison);
        renderStrategySummary(comparisonData.comparison);
      } else {
        // For specific strategy, render the order tables
        renderActiveOrders(activeOrders);
        renderClosedOrders(closedOrders);
      }

      // Always update these regardless of strategy selection
      renderMonthlyPerformance(monthlyPerformance);
      updatePerformanceChart();

      // Re-apply current sort if it exists and we're viewing a specific strategy
      if (selectedStrategy !== 'all' && currentSort.table && currentSort.column && currentSort.direction) {
        sortTable(currentSort.table, currentSort.column, currentSort.direction);
      }

      document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  }

  function updateMetrics(summaryData) {
    document.getElementById('totalCapital').textContent = `₹${formatNumber(summaryData.totalCapital || 0)}`;
    document.getElementById('totalProfit').textContent = `₹${formatNumber(summaryData.totalProfit || 0)}`;
    document.getElementById('totalLoss').textContent = `₹${formatNumber(summaryData.totalLoss || 0)}`;
    document.getElementById('orderStats').textContent = `${summaryData.openOrders || 0} / ${summaryData.totalOrders || 0}`;
  }

  function renderActiveOrders(orders) {
    // First apply sorting to the full dataset if needed
    let sortedOrders = [...orders];
    if (currentSort.table === 'activeOrdersTableBody' && currentSort.column) {
      sortedOrders = sortDataset(sortedOrders, currentSort.column, currentSort.direction);
    }

    const tableBody = document.getElementById('activeOrdersTableBody');
    tableBody.innerHTML = '';

    if (sortedOrders.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="12" class="text-center">No active orders</td>`;
      tableBody.appendChild(emptyRow);

      // Hide pagination if no orders
      document.getElementById('activeOrdersPagination').style.display = 'none';
      return;
    }

    // Show pagination if there are orders
    document.getElementById('activeOrdersPagination').style.display = 'flex';

    // Apply pagination
    const totalItems = sortedOrders.length;
    const currentPage = paginationSettings.activeOrders.currentPage;
    const itemsPerPage = paginationSettings.itemsPerPage;
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, totalItems);

    // Update pagination info
    document.getElementById('activeOrdersStart').textContent = totalItems > 0 ? startIndex + 1 : 0;
    document.getElementById('activeOrdersEnd').textContent = endIndex;
    document.getElementById('activeOrdersTotal').textContent = totalItems;

    // Calculate total PnL for all active orders
    let totalPnl = 0;
    sortedOrders.forEach(order => {
      const orderPnl = (order.current_price - order.entry_price) * order.quantity;
      totalPnl += orderPnl;
    });

    // Display total PnL with appropriate class
    const totalPnlElement = document.getElementById('totalActivePnl');
    if (totalPnlElement) {
      totalPnlElement.textContent = `₹${totalPnl.toFixed(2)}`;
      if (totalPnl >= 0) {
        totalPnlElement.className = 'fw-bold badge bg-success';
      } else {
        totalPnlElement.className = 'fw-bold badge bg-danger';
      }
    }

    // Update pagination buttons
    updatePaginationButtons('activeOrders', totalItems, currentPage, itemsPerPage);

    // Display only current page items
    const ordersToDisplay = sortedOrders.slice(startIndex, endIndex);

    ordersToDisplay.forEach(order => {
      const row = document.createElement('tr');
      row.classList.add('active-trade');

      // Calculate unrealized P&L
      const pnl = (order.current_price - order.entry_price) * order.quantity;
      const pnlPercent = ((order.current_price - order.entry_price) / order.entry_price) * 100;
      const pnlClass = pnl >= 0 ? 'profit' : 'loss';

      // Calculate days open
      const entryDate = new Date(order.entry_time);
      const today = new Date();
      const daysOpen = Math.floor((today - entryDate) / (1000 * 60 * 60 * 24));

      row.innerHTML = `
        <td>${order.symbol}</td>
        <td>${order.strike_price}</td>
        <td>${order.option_type}</td>
        <td>${order.entry_price.toFixed(2)}</td>
        <td>${order.current_price.toFixed(2)}</td>
        <td>${order.target_price.toFixed(2)}</td>
        <td>${order.stop_loss.toFixed(2)}</td>
        <td>${order.quantity}</td>
        <td>${new Date(order.entry_time).toLocaleString()}</td>
        <td>${daysOpen}</td>
        <td class="${pnlClass}">₹${pnl.toFixed(2)}</td>
        <td class="${pnlClass}">${pnlPercent.toFixed(2)}%</td>
      `;
      tableBody.appendChild(row);
    });
  }

  function renderClosedOrders(orders) {
    // Apply filter first
    const filteredOrders = applyOrderFilters(orders);

    // Then apply sorting to the full filtered dataset if needed
    let sortedOrders = [...filteredOrders];
    if (currentSort.table === 'closedOrdersTableBody' && currentSort.column) {
      sortedOrders = sortDataset(sortedOrders, currentSort.column, currentSort.direction);
    }

    const tableBody = document.getElementById('closedOrdersTableBody');
    tableBody.innerHTML = '';

    if (sortedOrders.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="11" class="text-center">No closed orders</td>`;
      tableBody.appendChild(emptyRow);

      // Hide pagination if no orders
      document.getElementById('closedOrdersPagination').style.display = 'none';
      return;
    }

    // Show pagination if there are orders
    document.getElementById('closedOrdersPagination').style.display = 'flex';

    // Apply pagination
    const totalItems = sortedOrders.length;
    const currentPage = paginationSettings.closedOrders.currentPage;
    const itemsPerPage = paginationSettings.itemsPerPage;
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, totalItems);

    // Update pagination info
    document.getElementById('closedOrdersStart').textContent = totalItems > 0 ? startIndex + 1 : 0;
    document.getElementById('closedOrdersEnd').textContent = endIndex;
    document.getElementById('closedOrdersTotal').textContent = totalItems;

    // Update pagination buttons
    updatePaginationButtons('closedOrders', totalItems, currentPage, itemsPerPage);

    // Display only current page items
    const ordersToDisplay = sortedOrders.slice(startIndex, endIndex);

    ordersToDisplay.forEach(order => {
      const row = document.createElement('tr');

      // Format status and P&L
      const statusClass = `status-${order.status.toLowerCase()}`;
      const pnlClass = order.pnl >= 0 ? 'profit' : 'loss';

      row.innerHTML = `
        <td>${order.symbol}</td>
        <td>${order.strike_price}</td>
        <td>${order.option_type}</td>
        <td>${order.entry_price.toFixed(2)}</td>
        <td>${order.exit_price.toFixed(2)}</td>
        <td>${order.quantity}</td>
        <td>${new Date(order.entry_time).toLocaleString()}</td>
        <td>${new Date(order.exit_time).toLocaleString()}</td>
        <td class="${statusClass}">${order.status}</td>
        <td class="${pnlClass}">₹${order.pnl.toFixed(2)}</td>
        <td class="${pnlClass}">${order.pnl_percentage.toFixed(2)}%</td>
      `;
      tableBody.appendChild(row);
    });
  }

  function updatePaginationButtons(tableType, totalItems, currentPage, itemsPerPage) {
    const paginationElement = document.getElementById(`${tableType}PageButtons`);
    paginationElement.innerHTML = '';

    const totalPages = Math.ceil(totalItems / itemsPerPage);

    // No need for pagination if only one page
    if (totalPages <= 1) {
      return;
    }

    // Previous button
    const prevLi = document.createElement('li');
    prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
    prevLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage - 1}">Previous</a>`;
    paginationElement.appendChild(prevLi);

    // Page buttons - show limited number of pages
    const maxVisiblePages = 5;
    let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

    // Adjust if we're at the end
    if (endPage - startPage + 1 < maxVisiblePages) {
      startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    // First page if not visible
    if (startPage > 1) {
      const firstLi = document.createElement('li');
      firstLi.className = 'page-item';
      firstLi.innerHTML = `<a class="page-link" href="#" data-page="1">1</a>`;
      paginationElement.appendChild(firstLi);

      if (startPage > 2) {
        const ellipsisLi = document.createElement('li');
        ellipsisLi.className = 'page-item disabled';
        ellipsisLi.innerHTML = `<a class="page-link" href="#">...</a>`;
        paginationElement.appendChild(ellipsisLi);
      }
    }

    // Page numbers
    for (let i = startPage; i <= endPage; i++) {
      const pageLi = document.createElement('li');
      pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
      pageLi.innerHTML = `<a class="page-link" href="#" data-page="${i}">${i}</a>`;
      paginationElement.appendChild(pageLi);
    }

    // Last page if not visible
    if (endPage < totalPages) {
      if (endPage < totalPages - 1) {
        const ellipsisLi = document.createElement('li');
        ellipsisLi.className = 'page-item disabled';
        ellipsisLi.innerHTML = `<a class="page-link" href="#">...</a>`;
        paginationElement.appendChild(ellipsisLi);
      }

      const lastLi = document.createElement('li');
      lastLi.className = 'page-item';
      lastLi.innerHTML = `<a class="page-link" href="#" data-page="${totalPages}">${totalPages}</a>`;
      paginationElement.appendChild(lastLi);
    }

    // Next button
    const nextLi = document.createElement('li');
    nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
    nextLi.innerHTML = `<a class="page-link" href="#" data-page="${currentPage + 1}">Next</a>`;
    paginationElement.appendChild(nextLi);

    // Add event listeners
    paginationElement.querySelectorAll('.page-link').forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();

        // Skip if disabled or current
        if (this.parentNode.classList.contains('disabled') ||
            this.parentNode.classList.contains('active')) {
          return;
        }

        const page = parseInt(this.dataset.page);
        if (!isNaN(page)) {
          // Set current page and re-render
          paginationSettings[tableType].currentPage = page;

          if (tableType === 'activeOrders') {
            renderActiveOrders(activeOrders);
          } else if (tableType === 'closedOrders') {
            renderClosedOrders(closedOrders);
          }
        }
      });
    });
  }

  function renderMonthlyPerformance(performance) {
    const tableBody = document.getElementById('monthlyPerformanceTableBody');
    tableBody.innerHTML = '';

    if (performance.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="9" class="text-center">No monthly performance data yet</td>`;
      tableBody.appendChild(emptyRow);
      return;
    }

    performance.forEach(month => {
      const row = document.createElement('tr');

      // Format month and year
      const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const monthDisplay = `${monthNames[month.month - 1]} ${month.year}`;

      // P&L formatting
      const pnlClass = month.total_pnl >= 0 ? 'profit' : 'loss';

      row.innerHTML = `
        <td>${monthDisplay}</td>
        <td>${month.total_orders}</td>
        <td>${month.profit_orders}</td>
        <td>${month.loss_orders}</td>
        <td>${month.win_rate.toFixed(2)}%</td>
        <td class="${pnlClass}">₹${month.total_pnl.toFixed(2)}</td>
        <td class="profit">${month.avg_profit_percentage.toFixed(2)}%</td>
        <td class="loss">${month.avg_loss_percentage.toFixed(2)}%</td>
        <td>₹${month.max_capital_required.toFixed(2)}</td>
      `;
      tableBody.appendChild(row);
    });
  }

  function renderStrategyComparison(orders) {
    const tableBody = document.getElementById('strategyComparisonTableBody');
    tableBody.innerHTML = '';

    // Extract strategy performance data
    const strategyData = {
      percent_change_tracker: {
        displayName: 'Conservative (5% Entry, 15% SL)',
        totalOrders: 0,
        winRate: 0,
        profitCount: 0,
        avgProfitPercent: 0,
        avgLossPercent: 0,
        totalPnl: 0,
        maxCapital: 0,
        roi: 0
      },
      aggressive_tracker: {
        displayName: 'Aggressive (10% Entry, 30% SL)',
        totalOrders: 0,
        winRate: 0,
        profitCount: 0,
        avgProfitPercent: 0,
        avgLossPercent: 0,
        totalPnl: 0,
        maxCapital: 0,
        roi: 0
      },
      high_risk_tracker: {
        displayName: 'High Risk (8% Entry, 60% SL)',
        totalOrders: 0,
        winRate: 0,
        profitCount: 0,
        avgProfitPercent: 0,
        avgLossPercent: 0,
        totalPnl: 0,
        maxCapital: 0,
        roi: 0
      }
    };

    // First pass: calculate basic stats for each order
    orders.forEach(order => {
      // Skip if strategy_name is missing
      if (!order.strategy_name) return;

      const strategyKey = order.strategy_name;

      // Skip if this is an unknown strategy
      if (!strategyData[strategyKey]) return;

      strategyData[strategyKey].totalOrders++;
      strategyData[strategyKey].totalPnl += order.pnl;

      if (order.pnl >= 0) {
        strategyData[strategyKey].profitCount++;
        strategyData[strategyKey].avgProfitPercent += order.pnl_percentage;
      } else {
        strategyData[strategyKey].avgLossPercent += order.pnl_percentage;
      }
    });

    // Second pass: calculate max capital by analyzing the capital deployed over time
    // Sort all orders by entry time to track capital chronologically
    const sortedOrders = [...orders].sort((a, b) => new Date(a.entry_time) - new Date(b.entry_time));

    // Track capital usage over time for each strategy
    const capitalTimeline = {
      percent_change_tracker: [],
      aggressive_tracker: [],
      high_risk_tracker: []
    };

    // Process orders chronologically to track capital usage
    sortedOrders.forEach(order => {
      if (!order.strategy_name || !capitalTimeline[order.strategy_name]) return;

      const strategy = order.strategy_name;
      const entryTime = new Date(order.entry_time);
      const exitTime = new Date(order.exit_time);
      const capital = order.quantity * order.entry_price;

      // Add capital at entry time
      capitalTimeline[strategy].push({
        time: entryTime,
        action: 'add',
        capital: capital
      });

      // Release capital at exit time
      capitalTimeline[strategy].push({
        time: exitTime,
        action: 'release',
        capital: capital
      });
    });

    // Calculate maximum capital deployed at any time for each strategy
    for (const strategy in capitalTimeline) {
      if (!capitalTimeline[strategy].length) continue;

      // Sort all capital events by time
      const events = capitalTimeline[strategy].sort((a, b) => a.time - b.time);

      let currentCapital = 0;
      let maxCapital = 0;

      // Process events chronologically
      events.forEach(event => {
        if (event.action === 'add') {
          currentCapital += event.capital;
        } else if (event.action === 'release') {
          currentCapital -= event.capital;
        }

        // Track maximum capital deployed
        if (currentCapital > maxCapital) {
          maxCapital = currentCapital;
        }
      });

      strategyData[strategy].maxCapital = maxCapital;
    }

    // Calculate averages and ROI
    for (const key in strategyData) {
      if (strategyData[key].totalOrders > 0) {
        strategyData[key].winRate = (strategyData[key].profitCount / strategyData[key].totalOrders) * 100;
        strategyData[key].avgProfitPercent = strategyData[key].profitCount > 0 ?
          (strategyData[key].avgProfitPercent / strategyData[key].profitCount) : 0;

        const lossCount = strategyData[key].totalOrders - strategyData[key].profitCount;
        strategyData[key].avgLossPercent = lossCount > 0 ?
          (strategyData[key].avgLossPercent / lossCount) : 0;

        strategyData[key].roi = strategyData[key].maxCapital > 0 ?
          (strategyData[key].totalPnl / strategyData[key].maxCapital) * 100 : 0;
      }
    }

    // Render table rows
    for (const key in strategyData) {
      const data = strategyData[key];

      // Skip if no orders for this strategy
      if (data.totalOrders === 0) continue;

      const row = document.createElement('tr');

      row.innerHTML = `
        <td>${data.displayName}</td>
        <td>${data.totalOrders}</td>
        <td>${data.winRate.toFixed(2)}%</td>
        <td class="profit">${data.avgProfitPercent.toFixed(2)}%</td>
        <td class="loss">${data.avgLossPercent.toFixed(2)}%</td>
        <td class="${data.totalPnl >= 0 ? 'profit' : 'loss'}">₹${data.totalPnl.toFixed(2)}</td>
        <td>₹${data.maxCapital.toFixed(2)}</td>
        <td class="${data.roi >= 0 ? 'profit' : 'loss'}">${data.roi.toFixed(2)}%</td>
      `;
      tableBody.appendChild(row);
    }
  }

  // New function to render the strategy summary table
  function renderStrategySummary(comparisonData) {
    const tableBody = document.getElementById('strategySummaryTableBody');
    tableBody.innerHTML = '';

    if (!comparisonData || comparisonData.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="7" class="text-center">No summary data available</td>`;
      tableBody.appendChild(emptyRow);
      return;
    }

    comparisonData.forEach(strategy => {
      const row = document.createElement('tr');
      let displayName;

      switch(strategy.strategy_name) {
        case 'percent_change_tracker':
          displayName = 'Conservative (5% Entry, 15% SL)';
          break;
        case 'aggressive_tracker':
          displayName = 'Aggressive (10% Entry, 30% SL)';
          break;
        case 'high_risk_tracker':
          displayName = 'High Risk (8% Entry, 60% SL)';
          break;
        default:
          displayName = strategy.strategy_name;
      }

      // Calculate net P&L
      const netPnl = (strategy.total_profit || 0) - Math.abs(strategy.total_loss || 0);

      row.innerHTML = `
        <td>${displayName}</td>
        <td>${strategy.open_orders || 0}</td>
        <td>${strategy.closed_orders || 0}</td>
        <td class="profit">₹${formatNumber(strategy.total_profit || 0)}</td>
        <td class="loss">₹${formatNumber(Math.abs(strategy.total_loss || 0))}</td>
        <td class="${netPnl >= 0 ? 'profit' : 'loss'}">₹${formatNumber(netPnl)}</td>
        <td>₹${formatNumber(strategy.current_capital || 0)}</td>
      `;
      tableBody.appendChild(row);
    });

    // Add a total row
    const totalRow = document.createElement('tr');
    totalRow.classList.add('fw-bold');

    // Calculate totals
    const totalOpenOrders = comparisonData.reduce((sum, item) => sum + (item.open_orders || 0), 0);
    const totalClosedOrders = comparisonData.reduce((sum, item) => sum + (item.closed_orders || 0), 0);
    const totalProfit = comparisonData.reduce((sum, item) => sum + (item.total_profit || 0), 0);
    const totalLoss = comparisonData.reduce((sum, item) => sum + Math.abs(item.total_loss || 0), 0);
    const totalNetPnl = totalProfit - totalLoss;
    const totalCapital = comparisonData.reduce((sum, item) => sum + (item.current_capital || 0), 0);

    totalRow.innerHTML = `
      <td>Total (All Strategies)</td>
      <td>${totalOpenOrders}</td>
      <td>${totalClosedOrders}</td>
      <td class="profit">₹${formatNumber(totalProfit)}</td>
      <td class="loss">₹${formatNumber(totalLoss)}</td>
      <td class="${totalNetPnl >= 0 ? 'profit' : 'loss'}">₹${formatNumber(totalNetPnl)}</td>
      <td>₹${formatNumber(totalCapital)}</td>
    `;
    tableBody.appendChild(totalRow);
  }

  function renderStrategyComparisonFromAPI(comparisonData) {
    const tableBody = document.getElementById('strategyComparisonTableBody');
    tableBody.innerHTML = '';

    if (!comparisonData || comparisonData.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = `<td colspan="8" class="text-center">No comparison data available</td>`;
      tableBody.appendChild(emptyRow);
      return;
    }

    comparisonData.forEach(strategy => {
      const row = document.createElement('tr');
      let displayName;

      switch(strategy.strategy_name) {
        case 'percent_change_tracker':
          displayName = 'Conservative (5% Entry, 15% SL)';
          break;
        case 'aggressive_tracker':
          displayName = 'Aggressive (10% Entry, 30% SL)';
          break;
        case 'high_risk_tracker':
          displayName = 'High Risk (8% Entry, 60% SL)';
          break;
        default:
          displayName = strategy.strategy_name;
      }

      row.innerHTML = `
        <td>${displayName}</td>
        <td>${strategy.total_orders}</td>
        <td>${strategy.win_rate.toFixed(2)}%</td>
        <td class="profit">${strategy.avg_profit_percentage.toFixed(2)}%</td>
        <td class="loss">${strategy.avg_loss_percentage.toFixed(2)}%</td>
        <td class="${strategy.net_pnl >= 0 ? 'profit' : 'loss'}">₹${formatNumber(strategy.net_pnl)}</td>
        <td>₹${formatNumber(strategy.max_capital)}</td>
        <td class="${strategy.roi >= 0 ? 'profit' : 'loss'}">${strategy.roi.toFixed(2)}%</td>
      `;
      tableBody.appendChild(row);
    });

    // Add a row for combined performance
    if (comparisonData.length > 1) {
      const combinedRow = document.createElement('tr');
      combinedRow.classList.add('fw-bold');

      // Calculate combined metrics
      const totalOrders = comparisonData.reduce((sum, item) => sum + item.total_orders, 0);
      const totalProfit = comparisonData.reduce((sum, item) => sum + (item.total_profit || 0), 0);
      const totalLoss = comparisonData.reduce((sum, item) => sum + Math.abs(item.total_loss || 0), 0);
      const netPnl = comparisonData.reduce((sum, item) => sum + item.net_pnl, 0);
      const maxCapital = comparisonData.reduce((sum, item) => sum + item.max_capital, 0);

      // Calculate combined win rate
      const winCount = comparisonData.reduce((sum, item) => sum + (item.win_count || Math.round(item.total_orders * item.win_rate / 100)), 0);
      const combinedWinRate = totalOrders > 0 ? (winCount / totalOrders) * 100 : 0;

      // ROI for combined strategies
      const combinedRoi = maxCapital > 0 ? (netPnl / maxCapital) * 100 : 0;

      combinedRow.innerHTML = `
        <td>Combined Performance</td>
        <td>${totalOrders}</td>
        <td>${combinedWinRate.toFixed(2)}%</td>
        <td class="profit">-</td>
        <td class="loss">-</td>
        <td class="${netPnl >= 0 ? 'profit' : 'loss'}">₹${formatNumber(netPnl)}</td>
        <td>₹${formatNumber(maxCapital)}</td>
        <td class="${combinedRoi >= 0 ? 'profit' : 'loss'}">${combinedRoi.toFixed(2)}%</td>
      `;
      tableBody.appendChild(combinedRow);
    }
  }

  // Function to update the performance chart
  function updatePerformanceChart() {
    // Get the canvas element
    const ctx = document.getElementById('performanceChart').getContext('2d');

    // Prepare data for the chart
    const performanceData = prepareStrategyChartData();

    // If chart already exists, destroy it first
    if (performanceChart) {
      performanceChart.destroy();
    }

    // Create new chart with separate datasets for each strategy
    performanceChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: performanceData.labels,
        datasets: [
          {
            label: 'Conservative Strategy P&L',
            data: performanceData.conservativePnl,
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 2,
            tension: 0.1
          },
          {
            label: 'Aggressive Strategy P&L',
            data: performanceData.aggressivePnl,
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 2,
            tension: 0.1
          },
          {
            label: 'High Risk Strategy P&L',
            data: performanceData.highRiskPnl,
            backgroundColor: 'rgba(255, 159, 64, 0.2)',
            borderColor: 'rgba(255, 159, 64, 1)',
            borderWidth: 2,
            tension: 0.1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: false
          }
        }
      }
    });
  }

  // Function to prepare data for the performance chart
  function prepareStrategyChartData() {
    // Sort closed orders by exit time
    const sortedOrders = [...closedOrders].sort((a, b) => new Date(a.exit_time) - new Date(b.exit_time));

    // Prepare data points
    const labels = [];
    const conservativePnl = [];
    const aggressivePnl = [];
    const highRiskPnl = [];
    let conservativeSum = 0;
    let aggressiveSum = 0;
    let highRiskSum = 0;

    // Group orders by day and strategy
    const dailyData = {};

    sortedOrders.forEach(order => {
      // Skip if no exit time or no strategy name
      if (!order.exit_time || !order.strategy_name) return;

      const exitDate = new Date(order.exit_time).toLocaleDateString();
      if (!dailyData[exitDate]) {
        dailyData[exitDate] = {
          conservative: 0,
          aggressive: 0,
          highRisk: 0
        };
      }

      // Add to the appropriate strategy bucket
      if (order.strategy_name === 'percent_change_tracker') {
        dailyData[exitDate].conservative += order.pnl;
      } else if (order.strategy_name === 'aggressive_tracker') {
        dailyData[exitDate].aggressive += order.pnl;
      } else if (order.strategy_name === 'high_risk_tracker') {
        dailyData[exitDate].highRisk += order.pnl;
      }
    });

    // Convert to arrays for the chart
    Object.keys(dailyData).sort((a, b) => new Date(a) - new Date(b)).forEach(date => {
      labels.push(date);

      // Update cumulative values
      conservativeSum += dailyData[date].conservative;
      aggressiveSum += dailyData[date].aggressive;
      highRiskSum += dailyData[date].highRisk;

      // Add to series
      conservativePnl.push(conservativeSum);
      aggressivePnl.push(aggressiveSum);
      highRiskPnl.push(highRiskSum);
    });

    return {
      labels,
      conservativePnl,
      aggressivePnl,
      highRiskPnl
    };
  }

  function applyOrderFilters(orders) {
    const filter = currentFilter;
    if (filter === 'all') {
      return orders;
    }

    return orders.filter(order => {
      if (filter === 'profit' && order.status === 'PROFIT') return true;
      if (filter === 'loss' && order.status === 'LOSS') return true;
      if (filter === 'open' && order.status === 'OPEN') return true;
      if (filter === 'expired' && order.status === 'EXPIRED') return true;
      return false;
    });
  }

  function applyFilters() {
    // Re-render closed orders with the new filter
    renderClosedOrders(closedOrders);
  }

  // Add a new function to sort the entire dataset
  function sortDataset(data, column, direction) {
    return [...data].sort((a, b) => {
      let aVal, bVal;

      // Determine values based on column type
      switch(column) {
        case 'symbol':
          aVal = a.symbol;
          bVal = b.symbol;
          break;
        case 'days':
          const aDate = new Date(a.entry_time);
          const bDate = new Date(b.entry_time);
          const today = new Date();
          aVal = Math.floor((today - aDate) / (1000 * 60 * 60 * 24));
          bVal = Math.floor((today - bDate) / (1000 * 60 * 60 * 24));
          break;
        case 'entry_time':
          aVal = new Date(a.entry_time).getTime();
          bVal = new Date(b.entry_time).getTime();
          break;
        case 'exit_time':
          aVal = new Date(a.exit_time).getTime();
          bVal = new Date(b.exit_time).getTime();
          break;
        case 'pnl':
          aVal = a.pnl !== undefined ? a.pnl : (a.current_price - a.entry_price) * a.quantity;
          bVal = b.pnl !== undefined ? b.pnl : (b.current_price - b.entry_price) * b.quantity;
          break;
        case 'pnl-percent':
          aVal = a.pnl_percentage !== undefined ? a.pnl_percentage : ((a.current_price - a.entry_price) / a.entry_price) * 100;
          bVal = b.pnl_percentage !== undefined ? b.pnl_percentage : ((b.current_price - b.entry_price) / b.entry_price) * 100;
          break;
        case 'status':
          aVal = a.status || '';
          bVal = b.status || '';
          break;
        default:
          aVal = a[column] || '';
          bVal = b[column] || '';
      }

      // Sort based on direction
      if (typeof aVal === 'number' && typeof bVal === 'number') {
        return direction === 'asc' ? aVal - bVal : bVal - aVal;
      } else {
        // Convert to strings for comparison
        aVal = String(aVal).toLowerCase();
        bVal = String(bVal).toLowerCase();
        return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
      }
    });
  }

  // ...existing code...

  function formatNumber(number) {
    return new Intl.NumberFormat('en-IN', {
      maximumFractionDigits: 2,
      minimumFractionDigits: 2
    }).format(number);
  }
</script>
</body>
</html>
